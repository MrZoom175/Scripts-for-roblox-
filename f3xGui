-- Gui to Lua
-- Version: 3.2

-- Instances:

local f3xUi = Instance.new("ScreenGui")

--Properties:

f3xUi.Name = "f3xUi"
f3xUi.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
f3xUi.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Module Scripts:

local fake_module_scripts = {}

do -- f3xUi.Explorer
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "Explorer"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local UI = Root:WaitForChild 'UI'
		local RunService = game:GetService 'RunService'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		local Roact = require(Vendor:WaitForChild 'Roact')
		local Maid = require(Libraries:WaitForChild 'Maid')
		local Signal = require(Libraries:WaitForChild 'Signal')
		
		-- Roact
		local new = Roact.createElement
		local Frame = require(UI:WaitForChild 'Frame')
		local ImageLabel = require(UI:WaitForChild 'ImageLabel')
		local ImageButton = require(UI:WaitForChild 'ImageButton')
		local TextLabel = require(UI:WaitForChild 'TextLabel')
		local ItemList = require(script:WaitForChild 'ItemList')
		
		-- Create component
		local Explorer = Roact.PureComponent:extend 'Explorer'
		
		function Explorer:init(props)
		    self:setState {
		        Items = {},
		        RowHeight = 18
		    }
		
		    -- Update batching data
		    self.UpdateQueues = {}
		    self.QueueTimers = {}
		
		    -- Item tracking data
		    self.LastId = 0
		    self.IdMap = {}
		    self.PendingParent = {}
		
		    -- Define item expanding function
		    self.ToggleExpand = function (ItemId)
		        return self:setState(function (State)
		            local Item = State.Items[ItemId]
		            Item.Expanded = not Item.Expanded
		            return { Items = State.Items }
		        end)
		    end
		end
		
		function Explorer:didUpdate(previousProps, previousState)
		
		    -- Trigger a scope change if prop changes
		    if previousProps.Scope ~= self.props.Scope then
		        self:UpdateScope(self.props.Scope)
		    end
		
		end
		
		function Explorer:UpdateScope(Scope)
		    local Core = self.props.Core
		    local Selection = Core.Selection
		
		    -- Clear previous cleanup maid
		    if self.ScopeMaid then
		        self.ScopeMaid:Destroy()
		    end
		
		    -- Create maid for cleanup
		    self.ScopeMaid = Maid.new()
		
		    -- Ensure new scope is defined
		    if not Scope then
		        return
		    end
		
		    -- Build initial tree
		    coroutine.resume(coroutine.create(function ()
		        self:UpdateTree()
		
		        -- Scroll to first selected item
		        if #Selection.Items > 0 then
		            local FocusedItem = Selection.IsSelected(Selection.Focus) and Selection.Focus or Selection.Items[1]
		            self:setState({
		                ScrollTo = self.IdMap[FocusedItem]
		            })
		        else
		            self:setState({
		                ScrollTo = Roact.None
		            })
		        end
		    end))
		
		    -- Listen for new and removing items
		    local Scope = Core.Targeting.Scope
		    self.ScopeMaid.Add = Scope.DescendantAdded:Connect(function (Item)
		        self:UpdateTree()
		    end)
		    self.ScopeMaid.Remove = Scope.DescendantRemoving:Connect(function (Item)
		        self:UpdateTree()
		    end)
		
		    -- Listen for selected items
		    self.ScopeMaid.Select = Selection.ItemsAdded:Connect(function (Items)
		        self:UpdateSelection(Items)
		
		        -- If single item selected, get item state
		        local ItemId = (#Items == 1) and self.IdMap[Items[1]]
		
		        -- Expand ancestors leading to item
		        self:setState(function (State)
		            local Changes = {}
		            local ItemState = State.Items[ItemId]
		            local ParentId = ItemState and self.IdMap[ItemState.Parent]
		            local ParentState = ParentId and State.Items[ParentId]
		
		            while ParentState do
		                ParentState.Expanded = true
		                Changes[ParentId] = ParentState
		                ParentId = self.IdMap[ParentState.Parent]
		                ParentState = State.Items[ParentId]
		            end
		
		            return {
		                Items = Support.Merge(State.Items, Changes),
		                ScrollTo = ItemId
		            }
		        end)
		    end)
		    self.ScopeMaid.Deselect = Selection.ItemsRemoved:Connect(function (Items)
		        self:UpdateSelection(Items)
		    end)
		
		end
		
		function Explorer:didMount()
		    self.Mounted = true
		
		    -- Create maid for cleanup on unmount
		    self.ItemMaid = Maid.new()
		
		    -- Set scope
		    self:UpdateScope(self.props.Scope)
		end
		
		function Explorer:willUnmount()
		    self.Mounted = false
		
		    -- Clean up resources
		    self.ScopeMaid:Destroy()
		    self.ItemMaid:Destroy()
		end
		
		local function IsTargetable(Item)
			return Item:IsA 'Model' or
				Item:IsA 'BasePart' or
				Item:IsA 'Tool' or
				Item:IsA 'Accessory' or
				Item:IsA 'Accoutrement'
		end
		
		function Explorer.IsItemIndexable(Item)
		    return (IsTargetable(Item) and Item.ClassName ~= 'Terrain') or
		        Item:IsA 'Folder'
		end
		
		function Explorer:UpdateTree()
		
		    -- Check if queue should be executed
		    if not self:ShouldExecuteQueue('Tree') then
		        return
		    end
		
		    -- Track order of each item
		    local OrderCounter = 1
		    local IdMap = self.IdMap
		
		    -- Perform update to state
		    self:setState(function (State)
		        local Changes = {}
		        local Descendants = self.props.Scope:GetDescendants()
		        local DescendantMap = Support.FlipTable(Descendants)
		
		        -- Check all items in scope
		        for Index, Item in ipairs(Descendants) do
		            local ItemId = IdMap[Item]
		            local ItemState = ItemId and State.Items[ItemId]
		
		            -- Update reordered items
		            if ItemState then
		                if ItemState.Order ~= OrderCounter then
		                    ItemState = Support.CloneTable(ItemState)
		                    ItemState.Order = OrderCounter
		                    Changes[ItemId] = ItemState
		                end
		                OrderCounter = OrderCounter + 1
		
		                -- Update parents in case scope changed
		                local ParentId = self.IdMap[ItemState.Parent]
		                if not State.Items[ParentId] then
		                    self:UpdateItemParent(Item, Changes, State)
		                end
		
		            -- Introduce new items
		            elseif self:BuildItemState(Item, self.props.Scope, OrderCounter, Changes, State) then
		                OrderCounter = OrderCounter + 1
		            end
		        end
		
		        -- Remove old items from state
		        for ItemId, Item in pairs(State.Items) do
		            local Object = Item.Instance
		            if not DescendantMap[Object] then
		
		                -- Clear state
		                Changes[ItemId] = Support.Blank
		
		                -- Clear ID
		                IdMap[Object] = nil
		
		                -- Clean up resources
		                self.ItemMaid[ItemId] = nil
		
		                -- Update parent child counter
		                local ParentId = Item.Parent and self.IdMap[Item.Parent]
		                local ParentState = self:GetStagedItemState(ParentId, Changes, State)
		                if ParentState then
		                    ParentState.Children[ItemId] = nil
		                    ParentState.Unlocked[ItemId] = nil
		                    ParentState.IsLocked = next(ParentState.Children) and not next(ParentState.Unlocked)
		                    Changes[ParentId] = ParentState
		                    self:PropagateLock(ParentState, Changes, State)
		                end
		
		            end
		        end
		
		        -- Update state
		        return { Items = Support.MergeWithBlanks(State.Items, Changes) }
		    end)
		
		end
		
		function Explorer:UpdateSelection(Items)
		    local Selection = self.props.Core.Selection
		
		    -- Queue changed items
		    self:QueueUpdate('Selection', Items)
		
		    -- Check if queue should be executed
		    if not self:ShouldExecuteQueue('Selection') then
		        return
		    end
		
		    -- Perform updates to state
		    self:setState(function (State)
		        local Changes = {}
		        local Queue = self:GetUpdateQueue('Selection')
		        for Items in pairs(Queue) do
		            for _, Item in ipairs(Items) do
		                local ItemId = self.IdMap[Item]
		                if ItemId then
		                    local ItemState = Support.CloneTable(State.Items[ItemId])
		                    ItemState.Selected = Selection.IsSelected(Item)
		                    Changes[ItemId] = ItemState
		                end
		            end
		        end
		        return { Items = Support.Merge(State.Items, Changes) }
		    end)
		
		end
		
		function Explorer:BuildItemState(Item, Scope, Order, Changes, State)
		    local Parent = Item.Parent
		    local ParentId = self.IdMap[Parent]
		
		    -- Check if indexable and visible in hierarchy
		    local InHierarchy = ParentId or (Parent == Scope)
		    if not (self.IsItemIndexable(Item) and InHierarchy) then
		        return nil
		    end
		
		    -- Assign ID
		    local ItemId = self.LastId + 1
		    self.LastId = ItemId
		    self.IdMap[Item] = ItemId
		
		    -- Check if item is a part
		    local IsPart = Item:IsA 'BasePart'
		
		    -- Create maid for cleanup when item is removed
		    local ItemMaid = Maid.new()
		    self.ItemMaid[ItemId] = ItemMaid
		
		    -- Prepare item state
		    local ItemState = {
		        Id = ItemId,
		        Name = Item.Name,
		        IsPart = IsPart,
		        IsLocked = IsPart and Item.Locked or nil,
		        Class = Item.ClassName,
		        Parent = Parent,
		        Children = {},
		        Unlocked = {},
		        Order = Order,
		        Expanded = nil,
		        Instance = Item,
		        Selected = self.props.Core.Selection.IsSelected(Item) or nil
		    }
		
		    -- Register item state into changes
		    Changes[ItemId] = ItemState
		
		    -- Update parent children
		    local ParentState = self:GetStagedItemState(ParentId, Changes, State)
		    if ParentState then
		        ParentState.Children[ItemId] = true
		        Changes[ParentId] = ParentState
		    end
		
		    -- Update children
		    for PendingChildId in pairs(self.PendingParent[Item] or {}) do
		        local ChildState = self:GetStagedItemState(PendingChildId, Changes, State)
		        if ChildState then
		            ItemState.Children[PendingChildId] = true
		            self:PropagateLock(ChildState, Changes, State)
		        end
		    end
		
		    -- Propagate lock to ancestors
		    self:PropagateLock(ItemState, Changes, State)
		
		    -- Listen to name changes
		    ItemMaid.Name = Item:GetPropertyChangedSignal('Name'):Connect(function ()
		
		        -- Queue change
		        self:QueueUpdate('Name', Item)
		
		        -- Check if queue should be executed
		        if not self:ShouldExecuteQueue('Name') then
		            return
		        end
		
		        -- Perform updates to state
		        self:setState(function (State)
		            local Changes = {}
		            local Queue = self:GetUpdateQueue('Name')
		            for Item in pairs(Queue) do
		                local ItemId = self.IdMap[Item]
		                local ItemState = Support.CloneTable(State.Items[ItemId])
		                ItemState.Name = Item.Name
		                Changes[ItemId] = ItemState
		            end
		            return { Items = Support.Merge(State.Items, Changes) }
		        end)
		
		    end)
		
		    -- Listen to parent changes
		    ItemMaid.Parent = Item:GetPropertyChangedSignal('Parent'):Connect(function ()
		        if not Item.Parent then
		            return
		        end
		
		        -- Queue change
		        self:QueueUpdate('Parent', Item)
		
		        -- Check if queue should be executed
		        if not self:ShouldExecuteQueue('Parent') then
		            return
		        end
		
		        -- Perform updates to state
		        self:setState(function (State)
		            local Changes = {}
		            local Queue = self:GetUpdateQueue('Parent')
		            for Item in pairs(Queue) do
		                self:UpdateItemParent(Item, Changes, State)
		            end
		            return { Items = Support.MergeWithBlanks(State.Items, Changes) }
		        end)
		
		        -- Update tree state
		        self:UpdateTree()
		    end)
		
		    -- Attach part-specific listeners
		    if IsPart then
		        ItemMaid.Locked = Item:GetPropertyChangedSignal('Locked'):Connect(function ()
		
		            -- Queue change
		            self:QueueUpdate('Lock', Item)
		
		            -- Check if queue should be executed
		            if not self:ShouldExecuteQueue('Lock') then
		                return
		            end
		
		            -- Perform updates to state
		            self:setState(function (State)
		                local Changes = {}
		                local Queue = self:GetUpdateQueue('Lock')
		                for Item in pairs(Queue) do
		                    self:UpdateItemLock(Item, Changes, State)
		                end
		                return { Items = Support.MergeWithBlanks(State.Items, Changes) }
		            end)
		
		        end)
		    end
		
		    -- Indicate that item state was created
		    return true
		
		end
		
		function Explorer:QueueUpdate(Type, Item)
		    self.UpdateQueues[Type] = Support.Merge(self.UpdateQueues[Type] or {}, {
		        [Item] = true
		    })
		end
		
		function Explorer:GetUpdateQueue(Type)
		
		    -- Get queue
		    local Queue = self.UpdateQueues[Type]
		    self.UpdateQueues[Type] = nil
		
		    -- Return queued items
		    return Queue
		
		end
		
		function Explorer:ShouldExecuteQueue(Type)
		    local ShouldExecute = self.QueueTimers[Type] or Support.CreateConsecutiveCallDeferrer(0.025)
		    self.QueueTimers[Type] = ShouldExecute
		
		    -- Wait until state updatable
		    if ShouldExecute() and self.Mounted then
		        return true
		    end
		end
		
		function Explorer:UpdateItemLock(Item, Changes, State)
		
		    -- Get staged item state
		    local ItemId = self.IdMap[Item]
		    local ItemState = self:GetStagedItemState(ItemId, Changes, State)
		    if not ItemState then
		        return
		    end
		
		    -- Update state
		    ItemState.IsLocked = Item.Locked
		    Changes[ItemId] = ItemState
		
		    -- Propagate lock state up hierarchy
		    self:PropagateLock(ItemState, Changes, State)
		
		end
		
		function Explorer:GetStagedItemState(ItemId, Changes, State)
		
		    -- Check if item staged yet
		    local StagedItemState = ItemId and Changes[ItemId]
		
		    -- Ensure item still exists
		    if not ItemId or (StagedItemState == Support.Blank) or
		        not (StagedItemState or State.Items[ItemId]) then
		        return
		    end
		
		    -- Return staged item state
		    return StagedItemState or Support.CloneTable(State.Items[ItemId])
		
		end
		
		function Explorer:UpdateItemParent(Item, Changes, State)
		
		    -- Get staged item state
		    local ItemId = self.IdMap[Item]
		    local ItemState = self:GetStagedItemState(ItemId, Changes, State)
		    if not ItemState then
		        return
		    end
		
		    -- Get current parent ID
		    local PreviousParentId = ItemState.Parent and self.IdMap[ItemState.Parent]
		
		    -- Set new parent ID
		    local Parent = Item.Parent
		    local ParentId = self.IdMap[Parent]
		    ItemState.Parent = Parent
		    Changes[ItemId] = ItemState
		
		    -- Queue parenting if parent item valid, but not yet registered
		    if not ParentId and not (Parent == Scope) then
		        if Parent:IsDescendantOf(Scope) then
		            self.PendingParent[Parent] = Support.Merge(self.PendingParent[Parent] or {}, { [ItemId] = true })
		        end
		    end
		
		    -- Update previous parent
		    local PreviousParentState = self:GetStagedItemState(PreviousParentId, Changes, State)
		    if PreviousParentState then
		        PreviousParentState.Children[ItemId] = nil
		        PreviousParentState.Unlocked[ItemId] = nil
		        PreviousParentState.IsLocked = next(PreviousParentState.Children) and not next(PreviousParentState.Unlocked)
		        Changes[PreviousParentId] = PreviousParentState
		    end
		
		    -- Update new parent
		    local ParentState = self:GetStagedItemState(ParentId, Changes, State)
		    if ParentState then
		        ParentState.Children[ItemId] = true
		        Changes[ParentId] = ParentState
		        self:PropagateLock(ItemState, Changes, State)
		    end
		
		end
		
		function Explorer:PropagateLock(ItemState, Changes, State)
		
		    -- Continue if upward propagation is possible
		    if not ItemState.Parent then
		        return
		    end
		
		    -- Start propagation from changed item
		    local ItemId = ItemState.Id
		    local ItemState = ItemState
		
		    -- Get item's parent state
		    repeat
		        local Parent = ItemState.Parent
		        local ParentId = Parent and self.IdMap[Parent]
		        local ParentState = self:GetStagedItemState(ParentId, Changes, State)
		        if ParentState then
		
		            -- Update parent lock state
		            ParentState.Unlocked[ItemId] = (not ItemState.IsLocked) and true or nil
		            ParentState.IsLocked = next(ParentState.Children) and not next(ParentState.Unlocked)
		            Changes[ParentId] = ParentState
		
		            -- Continue propagation upwards in the hierarchy
		            ItemId = ParentId
		            ItemState = ParentState
		
		        -- Stop propagation if parent being removed
		        else
		            ItemId = nil
		            ItemState = nil
		        end
		
		
		    -- Stop at highest reachable point in hierarchy
		    until
		        not ItemState
		end
		
		function Explorer:render()
		    local props = self.props
		    local state = self.state
		
		    -- Display window
		    return new(ImageLabel, {
		        Active = true,
		        Layout = 'List',
		        LayoutDirection = 'Vertical',
		        AnchorPoint = Vector2.new(1, 0),
		        Position = UDim2.new(1, -100, 0.6, -380/2),
		        Width = UDim.new(0, 145),
		        Height = 'WRAP_CONTENT',
		        Image = 'rbxassetid://2244248341',
		        ScaleType = 'Slice',
		        SliceCenter = Rect.new(4, 4, 12, 12),
		        ImageTransparency = 1 - 0.93,
		        ImageColor = '3B3B3B'
		    },
		    {
		        -- Window header
		        Header = new(TextLabel, {
		            Text = '  EXPLORER',
		            TextSize = 9,
		            Height = UDim.new(0, 14),
		            TextColor = 'FFFFFF',
		            TextTransparency = 1 - 0.6/2
		        },
		        {
		            CloseButton = new(ImageButton, {
		                Image = 'rbxassetid://2244452978',
		                ImageRectOffset = Vector2.new(0, 0),
		                ImageRectSize = Vector2.new(14, 14) * 2,
		                AspectRatio = 1,
		                AnchorPoint = Vector2.new(1, 0.5),
		                Position = UDim2.new(1, 0, 0.5, 0),
		                ImageTransparency = 1 - 0.34,
		                [Roact.Event.Activated] = props.Close
		            })
		        }),
		
		        -- Scrollable item list
		        ItemList = new(ItemList, {
		            Scope = props.Scope,
		            Items = state.Items,
		            ScrollTo = state.ScrollTo,
		            Core = props.Core,
		            IdMap = self.IdMap,
		            RowHeight = state.RowHeight,
		            ToggleExpand = self.ToggleExpand
		        })
		    })
		end
		
		return Explorer
	end
	fake_module_scripts[script] = module_script
end
do -- nil.ItemRow
	local script = Instance.new('ModuleScript', nil)
	script.Name = "ItemRow"
	local function module_script()
		local Root = script.Parent.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local UI = Root:WaitForChild 'UI'
		local UserInputService = game:GetService 'UserInputService'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		local Roact = require(Vendor:WaitForChild 'Roact')
		local Maid = require(Libraries:WaitForChild 'Maid')
		
		-- Roact
		local new = Roact.createElement
		local Frame = require(UI:WaitForChild 'Frame')
		local ImageLabel = require(UI:WaitForChild 'ImageLabel')
		local ImageButton = require(UI:WaitForChild 'ImageButton')
		local TextLabel = require(UI:WaitForChild 'TextLabel')
		local TextBox = require(UI:WaitForChild 'TextBox')
		
		-- Create component
		local ItemRow = Roact.PureComponent:extend 'ItemRow'
		
		function ItemRow:init()
		
		    -- Item button callback
		    self.OnActivated = function ()
		        self:HandleSelection()
		    end
		
		    -- Expand arrow callback
		    self.OnArrowActivated = function ()
		        self:ToggleExpand()
		    end
		
		    -- Lock button callback
		    self.OnLockActivated = function ()
		        self:ToggleLock()
		    end
		
		    -- Name button callback
		    self.OnNameActivated = function (rbx)
		        local CurrentTime = tick()
		        if self.LastNameClick and (CurrentTime - self.LastNameClick) <= 0.25 then
		            self:setState { EditingName = true }
		        else
		            self.LastNameClick = CurrentTime
		            self:HandleSelection()
		        end
		    end
		
		    -- Name input callback
		    self.OnNameInputBlur = function (rbx, EnterPressed)
		        if #rbx.Text > 0 then
		            self:SetName(rbx.Text)
		        end
		        self:setState { EditingName = Roact.None }
		    end
		
		end
		
		function ItemRow:GetParts()
		    local Object = self.props.Instance
		
		    -- Return part for parts
		    if Object:IsA 'BasePart' then
		        return { Object }
		
		    -- Return descendant parts for other items
		    else
		        local Parts = {}
		        for _, Part in pairs(Object:GetDescendants()) do
		            if Part:IsA 'BasePart' then
		                Parts[#Parts + 1] = Part
		            end
		        end
		        return Parts
		    end
		end
		
		function ItemRow:ToggleLock()
		    local props = self.props
		
		    -- Create history record
		    local Parts = self:GetParts()
		    local HistoryRecord = {
		        Parts = Parts,
		        BeforeLocked = Support.GetListMembers(Parts, 'Locked'),
		        AfterLocked = not props.IsLocked
		    }
		
		    function HistoryRecord:Unapply()
		        props.Core.SyncAPI:Invoke('SetLocked', self.Parts, self.BeforeLocked)
		    end
		
		    function HistoryRecord:Apply()
		        props.Core.SyncAPI:Invoke('SetLocked', self.Parts, self.AfterLocked)
		    end
		
		    -- Send lock toggling request to gameserver
		    HistoryRecord:Apply()
		
		    -- Register history record
		    props.Core.History.Add(HistoryRecord)
		
		end
		
		function ItemRow:SetName(Name)
		    local props = self.props
		
		    -- Create history record
		    local HistoryRecord = {
		        Items = { props.Instance },
		        BeforeName = props.Instance.Name,
		        AfterName = Name
		    }
		
		    function HistoryRecord:Unapply()
		        props.Core.SyncAPI:Invoke('SetName', self.Items, self.BeforeName)
		    end
		
		    function HistoryRecord:Apply()
		        props.Core.SyncAPI:Invoke('SetName', self.Items, self.AfterName)
		    end
		
		    -- Send renaming request to gameserver
		    HistoryRecord:Apply()
		
		    -- Register history record
		    props.Core.History.Add(HistoryRecord)
		
		end
		
		function ItemRow:HandleSelection()
		    local props = self.props
		    local Selection = props.Core.Selection
		    local Targeting = props.Core.Targeting
		
		    -- Check if scoping
		    local Scoping = UserInputService:IsKeyDown 'LeftAlt' or
		        UserInputService:IsKeyDown 'RightAlt'
		
		    -- Enter scope if requested
		    if Scoping then
		        Targeting:SetScope(props.Instance)
		        return
		    end
		
		    -- Check if multiselecting
		    local Multiselecting = UserInputService:IsKeyDown 'LeftControl' or
		        UserInputService:IsKeyDown 'RightControl'
		
		    -- Perform selection
		    if Multiselecting then
		        if not Selection.IsSelected(props.Instance) then
		            Selection.Add({ props.Instance }, true)
		        else
		            Selection.Remove({ props.Instance }, true)
		        end
		    else
		        Selection.Replace({ props.Instance }, true)
		    end
		end
		
		function ItemRow:ToggleExpand()
		    self.props.ToggleExpand(self.props.Id)
		end
		
		function ItemRow:didMount()
		    self.Maid = Maid.new()
		
		    local Targeting = self.props.Core.Targeting
		    local Item = self.props.Instance
		
		    -- Listen for targeting
		    self.Maid.TargetListener = Targeting.ScopeTargetChanged:Connect(function (ScopeTarget)
		        local IsTarget = self.state.Targeted
		        if (not IsTarget) and (ScopeTarget == Item) then
		            self:setState { Targeted = true }
		        elseif IsTarget and (ScopeTarget ~= Item) then
		            self:setState { Targeted = Roact.None }
		        end
		    end)
		end
		
		function ItemRow:willUnmount()
		    self.Maid = self.Maid:Destroy()
		end
		
		ItemRow.ClassIcons = {
		    Part = Vector2.new(2, 1),
		    MeshPart = Vector2.new(4, 8),
		    UnionOperation = Vector2.new(4, 8),
		    NegateOperation = Vector2.new(3, 8),
		    VehicleSeat = Vector2.new(6, 4),
		    Seat = Vector2.new(6, 4),
		    TrussPart = Vector2.new(2, 1),
		    CornerWedgePart = Vector2.new(2, 1),
		    WedgePart = Vector2.new(2, 1),
		    SpawnLocation = Vector2.new(6, 3),
		    Model = Vector2.new(3, 1),
		    Folder = Vector2.new(8, 8),
		    Tool = Vector2.new(8, 2),
		    Workspace = Vector2.new(10, 2),
		    Accessory = Vector2.new(3, 4),
		    Accoutrement = Vector2.new(3, 4)
		}
		
		function ItemRow:render()
		    local props = self.props
		    local state = self.state
		
		    -- Determine icon for class
		    local IconPosition = ItemRow.ClassIcons[props.Class] or Vector2.new(1, 1)
		
		    -- Item information
		    local Metadata = new(Frame, {
		        Layout = 'List',
		        LayoutDirection = 'Horizontal',
		        VerticalAlignment = 'Center'
		    },
		    {
		        StartSpacer = new(Frame, {
		            AspectRatio = (5 + 10 * props.Depth) / 18,
		            LayoutOrder = 0
		        }),
		
		        -- Class icon
		        Icon = new(ImageLabel, {
		            AspectRatio = 1,
		            Image = 'rbxassetid://2245672825',
		            ImageRectOffset = (IconPosition - Vector2.new(1, 1)) * Vector2.new(16, 16),
		            ImageRectSize = Vector2.new(16, 16),
		            Size = UDim2.new(1, 0, 12/18, 0),
		            LayoutOrder = 1
		        }),
		
		        IconSpacer = new(Frame, {
		            AspectRatio = 5/18,
		            LayoutOrder = 2
		        }),
		
		        -- Item name
		        NameContainer = new(ImageButton, {
		            Layout = 'List',
		            Width = 'WRAP_CONTENT',
		            LayoutOrder = 3,
		            [Roact.Event.Activated] = self.OnNameActivated
		        },
		        {
		            Name = (not state.EditingName) and new(TextLabel, {
		                TextSize = 13,
		                TextColor = 'FFFFFF',
		                Text = props.Name,
		                Width = 'WRAP_CONTENT'
		            }),
		            NameInput = state.EditingName and new(TextBox, {
		                TextSize = 13,
		                TextColor = 'FFFFFF',
		                Text = props.Name,
		                Width = 'WRAP_CONTENT',
		                [Roact.Event.FocusLost] = self.OnNameInputBlur
		            })
		        })
		    })
		
		    -- Item buttons
		    local Buttons = new(Frame, {
		        Layout = 'List',
		        LayoutDirection = 'Horizontal',
		        HorizontalAlignment = 'Right',
		        VerticalAlignment = 'Center',
		        Width = 'WRAP_CONTENT',
		        AnchorPoint = Vector2.new(1, 0.5),
		        Position = UDim2.new(1, 0, 0.5, 0)
		    },
		    {
		        -- Locking button
		        Lock = new(ImageButton, {
		            AspectRatio = 1,
		            DominantAxis = 'Height',
		            Image = 'rbxassetid://2244452978',
		            ImageRectOffset = Vector2.new(14 * (props.IsLocked and 2 or 1), 0) * 2,
		            ImageRectSize = Vector2.new(14, 14) * 2,
		            Size = UDim2.new(1, 0, 12/18, 0),
		            ImageTransparency = 1 - (props.IsLocked and 0.75 or 0.15),
		            LayoutOrder = 0,
		            [Roact.Event.Activated] = self.OnLockActivated
		        }),
		
		        Spacer = new(Frame, {
		            LayoutOrder = 1,
		            AspectRatio = 1/10
		        }),
		
		        -- Item expansion arrow
		        ArrowWrapper = next(props.Children) and new(Frame, {
		            AspectRatio = 1,
		            Size = UDim2.new(1, 0, 14/18, 0),
		            LayoutOrder = 2
		        },
		        {
		            Arrow = new(ImageButton, {
		                Image = 'rbxassetid://2244452978',
		                ImageRectOffset = Vector2.new(14 * 3, 0) * 2,
		                ImageRectSize = Vector2.new(14, 14) * 2,
		                Rotation = props.Expanded and 180 or 90,
		                ImageTransparency = 1 - 0.15,
		                [Roact.Event.Activated] = self.OnArrowActivated
		            })
		        }),
		
		        EndSpacer = new(Frame, {
		            LayoutOrder = 3,
		            AspectRatio = 1/20
		        })
		    })
		
		    -- Determine transparency from selection and targeting state
		    local Transparency = 1
		    if props.Selected then
		        Transparency = 1 - 0.15
		    elseif state.Targeted then
		        Transparency = 1 - 0.05
		    end
		
		    -- Return button with contents
		    return new(ImageButton, {
		        LayoutOrder = props.Order,
		        Size = UDim2.new(1, 0, 0, props.Height),
		        AutoButtonColor = false,
		        BackgroundColor3 = Color3.new(1, 1, 1),
		        BackgroundTransparency = Transparency,
		        [Roact.Event.Activated] = self.OnActivated
		    },
		    {
		        Metadata = Metadata,
		        Buttons = Buttons
		    })
		end
		
		return ItemRow
	end
	fake_module_scripts[script] = module_script
end
do -- nil.ItemList
	local script = Instance.new('ModuleScript', nil)
	script.Name = "ItemList"
	local function module_script()
		local Root = script.Parent.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local UI = Root:WaitForChild 'UI'
		local RunService = game:GetService 'RunService'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		local Roact = require(Vendor:WaitForChild 'Roact')
		local Maid = require(Libraries:WaitForChild 'Maid')
		
		-- Roact
		local new = Roact.createElement
		local Frame = require(UI:WaitForChild 'Frame')
		local ScrollingFrame = require(UI:WaitForChild 'ScrollingFrame')
		local ItemRow = require(script.Parent:WaitForChild 'ItemRow')
		
		-- Create component
		local ItemList = Roact.Component:extend 'ItemList'
		ItemList.defaultProps = {
		    MaxHeight = 300
		}
		
		function ItemList:init(props)
		    self:setState {
		        Min = 0,
		        Max = props.MaxHeight,
		        CanvasPosition = Vector2.new()
		    }
		
		    -- Create callback for updating canvas boundaries
		    self.UpdateBoundaries = function (rbx)
		        if self.Mounted then
		            self:setState {
		                CanvasPosition = rbx.CanvasPosition,
		                Min = rbx.CanvasPosition.Y - rbx.AbsoluteSize.Y,
		                Max = rbx.CanvasPosition.Y + rbx.AbsoluteSize.Y
		            }
		        end
		    end
		end
		
		function ItemList:didMount()
		    self.Mounted = true
		end
		
		function ItemList:willUnmount()
		    self.Mounted = false
		end
		
		function ItemList:didUpdate(previousProps, previousState)
		    local IsScrollTargetSet = self.props.ScrollTo and
		        (previousProps.ScrollTo ~= self.props.ScrollTo)
		
		    -- Reset canvas position whenever scope updates (unless a scrolling target is set)
		    if (previousProps.Scope ~= self.props.Scope) and (not IsScrollTargetSet) then
		        self:setState({
		            CanvasPosition = Vector2.new(0, 0);
		            Min = 0;
		            Max = self.props.MaxHeight;
		        })
		    end
		end
		
		function ItemList:render()
		    local props = self.props
		    local state = self.state
		
		    -- Keep track of how many items are out of view
		    local SkippedAbove = 0
		    local SkippedBelow = 0
		    local TargetCanvasPosition
		
		    -- Declare a button for each item
		    local ItemList = {}
		    local VisibleItemCount = 0
		    local ItemHeight = props.RowHeight
		
		    -- Go through each item in order
		    local OrderedItems = Support.Values(props.Items)
		    table.sort(OrderedItems, function (A, B)
		        return A.Order < B.Order
		    end)
		    for i = 1, #OrderedItems do
		        local Item = OrderedItems[i]
		
		        -- Get item parent state
		        local ParentId = Item.Parent and props.IdMap[Item.Parent]
		        local ParentState = ParentId and props.Items[ParentId]
		
		        -- Determine visibility and depth from ancestors
		        local Visible = true
		        local Depth = 0
		        if ParentId then
		            local ParentState = ParentState
		            while ParentState do
		
		                -- Stop if ancestor not visible
		                if not ParentState.Expanded then
		                    Visible = nil
		                    break
		
		                -- Count visible ancestors
		                else
		                    Depth = Depth + 1
		                end
		
		                -- Check next ancestor
		                local ParentId = props.IdMap[ParentState.Parent]
		                ParentState = props.Items[ParentId]
		
		            end
		        end
		
		        -- Set canvas position to begin at item if requested and out-of-view
		        if (Item.Id == props.ScrollTo) and (self.ScrolledTo ~= props.ScrollTo) then
		            local ItemPosition = VisibleItemCount * props.RowHeight
		            if ItemPosition < state.CanvasPosition.Y or
		               ItemPosition > (state.CanvasPosition.Y + props.MaxHeight) then
		                TargetCanvasPosition = Vector2.new(0, ItemPosition)
		                self.ScrolledTo = Item.Id
		            end
		        end
		
		        -- Calculate whether item is in view
		        if Visible then
		            VisibleItemCount = VisibleItemCount + 1
		            local ItemTop = (VisibleItemCount - 1) * props.RowHeight
		            if ItemTop < state.Min then
		                SkippedAbove = SkippedAbove + 1
		                Visible = nil
		            elseif ItemTop > state.Max then
		                SkippedBelow = SkippedBelow + 1
		                Visible = nil
		            end
		        end
		
		        -- Declare component for item
		        ItemList[Item.Id] = Visible and new(ItemRow, Support.Merge({}, Item, {
		            Depth = Depth,
		            Core = props.Core,
		            ToggleExpand = props.ToggleExpand,
		            Height = props.RowHeight
		        }))
		    end
		
		    return new(ScrollingFrame, {
		        Layout = 'List',
		        LayoutDirection = 'Vertical',
		        CanvasSize = UDim2.new(1, -2, 0, VisibleItemCount * props.RowHeight),
		        Size = UDim2.new(1, 0, 0, VisibleItemCount * props.RowHeight),
		        CanvasPosition = TargetCanvasPosition or state.CanvasPosition,
		        ScrollBarThickness = 4,
		        ScrollBarImageTransparency = 0.6,
		        VerticalScrollBarInset = 'ScrollBar',
		        [Roact.Change.CanvasPosition] = self.UpdateBoundaries,
		        [Roact.Children] = Support.Merge(ItemList, {
		            TopSpacer = new(Frame, {
		                Size = UDim2.new(0, 0, 0, SkippedAbove * props.RowHeight),
		                LayoutOrder = 0
		            }),
		            BottomSpacer = new(Frame, {
		                Size = UDim2.new(0, 0, 0, SkippedBelow * props.RowHeight),
		                LayoutOrder = #OrderedItems + 1
		            }),
		            SizeConstraint = new('UISizeConstraint', {
		                MinSize = Vector2.new(0, 20),
		                MaxSize = Vector2.new(math.huge, props.MaxHeight)
		            })
		        })
		    })
		end
		
		return ItemList
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.Frame
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "Frame"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		
		-- Roact
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Create component
		local Frame = Roact.PureComponent:extend 'Frame'
		
		-- Set defaults
		Frame.defaultProps = {
		    BackgroundTransparency = 1,
		    BorderSizePixel = 0,
		    Size = UDim2.new(1, 0, 1, 0)
		}
		
		function Frame:render()
		    local props = Support.CloneTable(self.props)
		    local state = self.state
		
		    -- Include aspect ratio constraint if specified
		    if props.AspectRatio then
		        local Constraint = new('UIAspectRatioConstraint', {
		            AspectRatio = props.AspectRatio
		        })
		
		        -- Insert constraint into children
		        props[Roact.Children] = Support.Merge(
		            { AspectRatio = Constraint },
		            props[Roact.Children] or {}
		        )
		
		        -- Base height off width using the aspect ratio
		        if props.DominantAxis == 'Width' then
		            props.SizeConstraint = 'RelativeXX'
		            if typeof(props.Width) == 'UDim' then
		                props.Height = UDim.new(props.Width.Scale / props.AspectRatio, 0)
		            else
		                props.Size = UDim2.new(
		                    props.Size.X,
		                    UDim.new(props.Size.X.Scale / props.AspectRatio, 0)
		                )
		            end
		
		        -- Base width off height using the aspect ratio
		        elseif props.DominantAxis == 'Height' then
		            props.SizeConstraint = 'RelativeYY'
		            if typeof(props.Height) == 'UDim' then
		                props.Width = UDim.new(props.Height.Scale * props.AspectRatio, 0)
		            else
		                props.Size = UDim2.new(
		                    UDim.new(props.Size.Y.Scale * props.AspectRatio, 0),
		                    props.Size.Y
		                )
		            end
		        end
		    end
		
		    -- Include list layout if specified
		    if props.Layout == 'List' then
		        local Layout = new('UIListLayout', {
		            FillDirection = props.LayoutDirection,
		            Padding = props.LayoutPadding,
		            HorizontalAlignment = props.HorizontalAlignment,
		            VerticalAlignment = props.VerticalAlignment,
		            SortOrder = props.SortOrder or 'LayoutOrder',
		            [Roact.Ref] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end,
		            [Roact.Change.AbsoluteContentSize] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end
		        })
		
		        -- Update size
		        props.Size = self:GetSize()
		
		        -- Insert layout into children
		        props[Roact.Children] = Support.Merge(
		            { Layout = Layout },
		            props[Roact.Children]
		        )
		    end
		
		    -- Filter out custom properties
		    props.AspectRatio = nil
		    props.DominantAxis = nil
		    props.Layout = nil
		    props.LayoutDirection = nil
		    props.LayoutPadding = nil
		    props.HorizontalAlignment = nil
		    props.VerticalAlignment = nil
		    props.HorizontalPadding = nil
		    props.VerticalPadding = nil
		    props.SortOrder = nil
		    props.Width = nil
		    props.Height = nil
		    props.ResizeParent = nil
		
		    -- Display component in wrapper
		    return new('Frame', props)
		
		end
		
		function Frame:GetSize(ContentSize)
		    local props = self.props
		    
		    -- Determine dynamic dimensions
		    local DynamicWidth = props.Size == 'WRAP_CONTENT' or
		        props.Width == 'WRAP_CONTENT'
		    local DynamicHeight = props.Size == 'WRAP_CONTENT' or
		        props.Height == 'WRAP_CONTENT'
		    local DynamicSize = DynamicWidth or DynamicHeight
		
		    -- Get padding from props
		    local Padding = UDim2.new(
		        0, props.HorizontalPadding or 0,
		        0, props.VerticalPadding or 0
		    )
		
		    -- Calculate size based on content if dynamic
		    return Padding + UDim2.new(
		        (ContentSize and DynamicWidth) and UDim.new(0, ContentSize.X) or
		            (typeof(props.Width) == 'UDim' and props.Width or props.Size.X),
		        (ContentSize and DynamicHeight) and UDim.new(0, ContentSize.Y) or
		            (typeof(props.Height) == 'UDim' and props.Height or props.Size.Y)
		    )
		end
		
		function Frame:UpdateContentSize(Layout)
		    if not (Layout and Layout.Parent) then
		        return
		    end
		
		    -- Set container size based on content
		    Layout.Parent.Size = self:GetSize(Layout.AbsoluteContentSize)
		
		    -- Set parent size based on content if specified
		    local ResizeParent = self.props.ResizeParent
		    local Parent = ResizeParent and Layout.Parent.Parent
		    if ResizeParent and Parent then
		        local ParentWidth = Parent.Size.X
		        local ParentHeight = Parent.Size.Y
		        if Support.IsInTable(ResizeParent, 'WIDTH') then
		            ParentWidth = UDim.new(0, Layout.Parent.AbsoluteSize.X)
		        end
		        if Support.IsInTable(ResizeParent, 'HEIGHT') then
		            ParentHeight = UDim.new(0, Layout.Parent.AbsoluteSize.Y)
		        end
		        Parent.Size = UDim2.new(ParentWidth, ParentHeight)
		    end
		end
		
		return Frame
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.ImageButton
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "ImageButton"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		
		-- Roact
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Create component
		local ImageButton = Roact.PureComponent:extend 'ImageButton'
		
		-- Set defaults
		ImageButton.defaultProps = {
		    BackgroundTransparency = 1,
		    BorderSizePixel = 0,
		    Size = UDim2.new(1, 0, 1, 0),
		    Image = ''
		}
		
		function ImageButton:render()
		    local props = Support.CloneTable(self.props)
		    local state = self.state
		
		    -- Include aspect ratio constraint if specified
		    if props.AspectRatio then
		        local Constraint = new('UIAspectRatioConstraint', {
		            AspectRatio = props.AspectRatio
		        })
		
		        -- Insert constraint into children
		        props[Roact.Children] = Support.Merge(
		            { AspectRatio = Constraint },
		            props[Roact.Children] or {}
		        )
		
		        -- Base height off width using the aspect ratio
		        if props.DominantAxis == 'Width' then
		            props.SizeConstraint = 'RelativeXX'
		            if typeof(props.Width) == 'UDim' then
		                props.Height = UDim.new(props.Width.Scale / props.AspectRatio, 0)
		            else
		                props.Size = UDim2.new(
		                    props.Size.X,
		                    UDim.new(props.Size.X.Scale / props.AspectRatio, 0)
		                )
		            end
		
		        -- Base width off height using the aspect ratio
		        elseif props.DominantAxis == 'Height' then
		            props.SizeConstraint = 'RelativeYY'
		            if typeof(props.Height) == 'UDim' then
		                props.Width = UDim.new(props.Height.Scale * props.AspectRatio, 0)
		            else
		                props.Size = UDim2.new(
		                    UDim.new(props.Size.Y.Scale * props.AspectRatio, 0),
		                    props.Size.Y
		                )
		            end
		        end
		    end
		
		    -- Include list layout if specified
		    if props.Layout == 'List' then
		        local Layout = new('UIListLayout', {
		            FillDirection = props.LayoutDirection,
		            Padding = props.LayoutPadding,
		            HorizontalAlignment = props.HorizontalAlignment,
		            VerticalAlignment = props.VerticalAlignment,
		            SortOrder = props.SortOrder or 'LayoutOrder',
		            [Roact.Ref] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end,
		            [Roact.Change.AbsoluteContentSize] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end
		        })
		
		        -- Update size
		        props.Size = self:GetSize()
		
		        -- Insert layout into children
		        props[Roact.Children] = Support.Merge(
		            { Layout = Layout },
		            props[Roact.Children]
		        )
		    end
		
		    -- Parse hex colors
		    if type(props.ImageColor) == 'string' then
		        local R, G, B = props.ImageColor:lower():match('#?(..)(..)(..)')
		        props.ImageColor3 = Color3.fromRGB(tonumber(R, 16), tonumber(G, 16), tonumber(B, 16))
		    end
		
		    -- Filter out custom properties
		    props.AspectRatio = nil
		    props.DominantAxis = nil
		    props.Layout = nil
		    props.LayoutDirection = nil
		    props.LayoutPadding = nil
		    props.HorizontalAlignment = nil
		    props.VerticalAlignment = nil
		    props.HorizontalPadding = nil
		    props.VerticalPadding = nil
		    props.SortOrder = nil
		    props.Width = nil
		    props.Height = nil
		    props.ImageColor = nil
		
		    -- Display component in wrapper
		    return new('ImageButton', props)
		
		end
		
		function ImageButton:GetSize(ContentSize)
		    local props = self.props
		    
		    -- Determine dynamic dimensions
		    local DynamicWidth = props.Size == 'WRAP_CONTENT' or
		        props.Width == 'WRAP_CONTENT'
		    local DynamicHeight = props.Size == 'WRAP_CONTENT' or
		        props.Height == 'WRAP_CONTENT'
		    local DynamicSize = DynamicWidth or DynamicHeight
		
		    -- Get padding from props
		    local Padding = UDim2.new(
		        0, props.HorizontalPadding or 0,
		        0, props.VerticalPadding or 0
		    )
		    
		    -- Calculate size based on content if dynamic
		    return Padding + UDim2.new(
		        (ContentSize and DynamicWidth) and UDim.new(0, ContentSize.X) or
		            (typeof(props.Width) == 'UDim' and props.Width or props.Size.X),
		        (ContentSize and DynamicHeight) and UDim.new(0, ContentSize.Y) or
		            (typeof(props.Height) == 'UDim' and props.Height or props.Size.Y)
		    )
		end
		
		function ImageButton:UpdateContentSize(Layout)
		    if not (Layout and Layout.Parent) then
		        return
		    end
		
		    -- Set container size based on content
		    Layout.Parent.Size = self:GetSize(Layout.AbsoluteContentSize)
		end
		
		return ImageButton
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.ImageLabel
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "ImageLabel"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		
		-- Roact
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Create component
		local ImageLabel = Roact.PureComponent:extend 'ImageLabel'
		
		-- Set defaults
		ImageLabel.defaultProps = {
		    BackgroundTransparency = 1,
		    BorderSizePixel = 0,
		    Size = UDim2.new(1, 0, 1, 0),
		    Image = ''
		}
		
		function ImageLabel:render()
		    local props = Support.CloneTable(self.props)
		    local state = self.state
		
		    -- Include aspect ratio constraint if specified
		    if props.AspectRatio then
		        local Constraint = new('UIAspectRatioConstraint', {
		            AspectRatio = props.AspectRatio
		        })
		
		        -- Insert constraint into children
		        props[Roact.Children] = Support.Merge(
		            { AspectRatio = Constraint },
		            props[Roact.Children] or {}
		        )
		    end
		
		    -- Include list layout if specified
		    if props.Layout == 'List' then
		        local Layout = new('UIListLayout', {
		            FillDirection = props.LayoutDirection,
		            Padding = props.LayoutPadding,
		            HorizontalAlignment = props.HorizontalAlignment,
		            VerticalAlignment = props.VerticalAlignment,
		            SortOrder = props.SortOrder or 'LayoutOrder',
		            [Roact.Ref] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end,
		            [Roact.Change.AbsoluteContentSize] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end
		        })
		
		        -- Update size
		        props.Size = self:GetSize()
		
		        -- Insert layout into children
		        props[Roact.Children] = Support.Merge(
		            { Layout = Layout },
		            props[Roact.Children]
		        )
		    end
		
		    -- Parse hex colors
		    if type(props.ImageColor) == 'string' then
		        local R, G, B = props.ImageColor:lower():match('#?(..)(..)(..)')
		        props.ImageColor3 = Color3.fromRGB(tonumber(R, 16), tonumber(G, 16), tonumber(B, 16))
		    end
		
		    -- Filter out custom properties
		    props.AspectRatio = nil
		    props.Layout = nil
		    props.LayoutDirection = nil
		    props.LayoutPadding = nil
		    props.HorizontalAlignment = nil
		    props.VerticalAlignment = nil
		    props.HorizontalPadding = nil
		    props.VerticalPadding = nil
		    props.SortOrder = nil
		    props.Width = nil
		    props.Height = nil
		    props.ImageColor = nil
		
		    -- Display component in wrapper
		    return new('ImageLabel', props)
		
		end
		
		function ImageLabel:GetSize(ContentSize)
		    local props = self.props
		    
		    -- Determine dynamic dimensions
		    local DynamicWidth = props.Size == 'WRAP_CONTENT' or
		        props.Width == 'WRAP_CONTENT'
		    local DynamicHeight = props.Size == 'WRAP_CONTENT' or
		        props.Height == 'WRAP_CONTENT'
		    local DynamicSize = DynamicWidth or DynamicHeight
		
		    -- Get padding from props
		    local Padding = UDim2.new(
		        0, props.HorizontalPadding or 0,
		        0, props.VerticalPadding or 0
		    )
		    
		    -- Calculate size based on content if dynamic
		    return Padding + UDim2.new(
		        (ContentSize and DynamicWidth) and UDim.new(0, ContentSize.X) or
		            (typeof(props.Width) == 'UDim' and props.Width or props.Size.X),
		        (ContentSize and DynamicHeight) and UDim.new(0, ContentSize.Y) or
		            (typeof(props.Height) == 'UDim' and props.Height or props.Size.Y)
		    )
		end
		
		function ImageLabel:UpdateContentSize(Layout)
		    if not (Layout and Layout.Parent) then
		        return
		    end
		
		    -- Set container size based on content
		    Layout.Parent.Size = self:GetSize(Layout.AbsoluteContentSize)
		end
		
		return ImageLabel
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.LoadingSpinner
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "LoadingSpinner"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local UI = Root:WaitForChild 'UI'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		local Roact = require(Vendor:WaitForChild 'Roact')
		
		-- Roact
		local new = Roact.createElement
		local ImageLabel = require(UI:WaitForChild 'ImageLabel')
		
		-- Create component
		local LoadingSpinner = Roact.PureComponent:extend 'LoadingSpinner'
		
		function LoadingSpinner:init()
		    self.instance = Roact.createRef()
		end
		
		function LoadingSpinner:didMount()
		    coroutine.wrap(function ()
		        self.Running = true
		        while self.Running and self.instance.current do
		            local Spinner = self.instance.current
		            Spinner.Rotation = (Spinner.Rotation + 12) % 360
		            wait(0.01)
		        end
		    end)()
		end
		
		function LoadingSpinner:willUnmount()
		    self.Running = nil
		end
		
		function LoadingSpinner:render()
		
		    -- Prepare props
		    local props = Support.Merge({}, self.props or {}, {
		        [Roact.Ref] = self.instance,
		        Image = 'rbxassetid://1932255814',
		        AspectRatio = 1
		    })
		
		    -- Display component in wrapper
		    return new(ImageLabel, props)
		
		end
		
		return LoadingSpinner
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.ScopeHUD
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "ScopeHUD"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local Workspace = game:GetService('Workspace')
		local ContextActionService = game:GetService('ContextActionService')
		local UserInputService = game:GetService('UserInputService')
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local Maid = require(Libraries:WaitForChild 'Maid')
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		
		-- Roact
		local new = Roact.createElement
		local ScopeHierarchyItemButton = require(script:WaitForChild 'ScopeHierarchyItemButton')
		local HotkeyTooltip = require(script:WaitForChild 'HotkeyTooltip')
		local ModeToggle = require(script:WaitForChild 'ModeToggle')
		
		-- Create component
		local ScopeHUD = Roact.PureComponent:extend 'ScopeHUD'
		
		--- Creates callbacks and sets up initial state.
		function ScopeHUD:init(props)
		    self.Maid = Maid.new()
		    self.LayoutRef = Roact.createRef()
		    self.ContainerSize, self.UpdateContainerSize = Roact.createBinding(UDim2.new(0, 0, 0, 38/2))
		
		    --- Processes input, listens for hover start
		    function self.OnInputBegin(rbx, Input, WasProcessed)
		        if WasProcessed then
		            return
		        end
		
		        -- Set hovering state
		        if (Input.UserInputType.Name == 'MouseMovement') or
		           (Input.UserInputType.Name == 'Touch') then
		            self:setState({
		                IsHovering = true
		            })
		        end
		    end
		
		    --- Processes input, listens for hover end
		    function self.OnInputEnd(rbx, Input, WasProcessed)
		        if (Input.UserInputType.Name == 'MouseMovement') or
		           (Input.UserInputType.Name == 'Touch') then
		            self:setState({
		                IsHovering = false
		            })
		        end
		    end
		
		    --- Processes requests from buttons to set scope
		    function self.SetScopeFromButton(NewScope)
		        self.props.Core.Targeting:SetScope(NewScope)
		    end
		
		    -- Set initial state
		    self:UpdateTargetingState()
		    self:setState({
		        IsHovering = false;
		        IsToolModeEnabled = (self.props.Core.Mode == 'Tool')
		    })
		end
		
		--- Updates the current scope and target state.
		function ScopeHUD:UpdateTargetingState()
		    local Targeting = self.props.Core.Targeting
		    local Scope = Targeting.Scope
		    local DirectTarget, ScopeTarget = Targeting:UpdateTarget()
		    return self:setState({
		        Scope = Scope or Roact.None;
		        ScopeTarget = ScopeTarget or Roact.None;
		        DirectTarget = DirectTarget or Roact.None;
		        IsScopeLocked = Targeting.IsScopeLocked;
		    })
		end
		
		--- Begins tracking scope and target changes.
		function ScopeHUD:didMount()
		    self:UpdateTargetingState()
		
		    -- Set up targeting change listeners
		    local Targeting = self.props.Core.Targeting
		    self.Maid.ScopeChangeListener = Targeting.ScopeChanged:Connect(function (Scope)
		        Targeting:UpdateTarget()
		        self:setState({
		            Scope = Scope or Roact.None;
		        })
		    end)
		    self.Maid.ScopeTargetChangeListener = Targeting.ScopeTargetChanged:Connect(function (ScopeTarget)
		        self:setState({
		            ScopeTarget = ScopeTarget or Roact.None;
		        })
		    end)
		    self.Maid.TargetChangeListener = Targeting.TargetChanged:Connect(function (DirectTarget)
		        self:setState({
		            DirectTarget = DirectTarget or Roact.None;
		        })
		    end)
		    self.Maid.ScopeLockChangeListener = Targeting.ScopeLockChanged:Connect(function (IsScopeLocked)
		        self:setState({
		            IsScopeLocked = IsScopeLocked;
		        })
		    end)
		
		    -- Set up alt key listeners
		    local function AltKeyCallback(_, State, Input)
		        if State.Name == 'Begin' then
		            self:setState({
		                IsAltDown = true;
		            })
		        elseif State.Name == 'End' then
		            self:setState({
		                IsAltDown = false;
		            })
		        end
		        return Enum.ContextActionResult.Pass
		    end
		    ContextActionService:BindAction('BT/ScopeHUD: Scope', AltKeyCallback, false,
		        Enum.KeyCode.LeftAlt,
		        Enum.KeyCode.RightAlt
		    )
		
		    -- Set up content size listener
		    if self.LayoutRef.current then
		        local Layout = self.LayoutRef.current
		        local LayoutChanged = Layout:GetPropertyChangedSignal('AbsoluteContentSize')
		        self.UpdateContainerSize(UDim2.new(0, Layout.AbsoluteContentSize.X, 0, 38/2))
		        self.Maid.LayoutListener = LayoutChanged:Connect(function ()
		            self.UpdateContainerSize(UDim2.new(0, Layout.AbsoluteContentSize.X, 0, 38/2))
		        end)
		    end
		end
		
		--- Cleans up tracking resources.
		function ScopeHUD:willUnmount()
		    self.Maid:Destroy()
		end
		
		function ScopeHUD:render()
		    return new('Frame', {
		        Active = true;
		        Draggable = true;
		        Position = self.state.IsToolModeEnabled and
		            UDim2.new(0, 10/2, 1, -8/2) or
		            UDim2.new(0, 10/2, 0, 8/2);
		        AnchorPoint = self.state.IsToolModeEnabled and
		            Vector2.new(0, 1) or
		            Vector2.new(0, 0);
		        Size = self.ContainerSize;
		        BackgroundTransparency = 1;
		        [Roact.Event.InputBegan] = self.OnInputBegin;
		        [Roact.Event.InputEnded] = self.OnInputEnd;
		    },
		    Support.Merge(self:BuildScopeHierarchyButtons(), {
		        Layout = new('UIListLayout', {
		            [Roact.Ref] = self.LayoutRef;
		            FillDirection = Enum.FillDirection.Horizontal;
		            HorizontalAlignment = Enum.HorizontalAlignment.Left;
		            VerticalAlignment = Enum.VerticalAlignment.Center;
		            SortOrder = Enum.SortOrder.LayoutOrder;
		            Padding = UDim.new(0, 5/2);
		        });
		        ModeToggle = new(ModeToggle, {
		            Core = self.props.Core;
		            IsToolModeEnabled = self.state.IsToolModeEnabled;
		        });
		    }))
		end
		
		--- Returns whether it should be possible to scope into the given item.
		-- @returns boolean
		local function IsItemScopable(Item)
		    return Item:IsA('Model')
		        or Item:IsA('Folder')
		        or Item:IsA('Tool')
		        or Item:IsA('Accessory')
		        or Item:IsA('Accoutrement')
		        or (Item:IsA('BasePart') and Item:FindFirstChildWhichIsA('BasePart', true))
		end
		
		--- Builds and returns a button for each item in the scope hierarchy.
		-- @returns ScopeHierarchyItemButton[]
		function ScopeHUD:BuildScopeHierarchyButtons()
		    local Hierarchy = {}
		    local Buttons = {}
		
		    -- Navigate up hierarchy from scope target
		    local CurrentScopePosition = self.state.ScopeTarget or
		                                 self.state.Scope
		    while (CurrentScopePosition ~= nil) and
		          (CurrentScopePosition ~= Workspace.Parent) do
		        table.insert(Hierarchy, 1, CurrentScopePosition)
		        CurrentScopePosition = CurrentScopePosition.Parent
		    end
		
		    -- Create button for each scope hierarchy item
		    for Index, ScopePosition in ipairs(Hierarchy) do
		        Buttons[Index] = new(ScopeHierarchyItemButton, {
		            Instance = ScopePosition;
		            IsTarget = (self.state.ScopeTarget == ScopePosition);
		            IsScopeParent = self.state.Scope and (self.state.Scope.Parent == ScopePosition);
		            IsScope = (self.state.Scope == ScopePosition);
		            IsScopable = (self.state.ScopeTarget == ScopePosition) and IsItemScopable(ScopePosition);
		            IsScopeLocked = self.state.IsScopeLocked;
		            SetScopeFromButton = self.SetScopeFromButton;
		            IsAltDown = self.state.IsAltDown;
		            LayoutOrder = Index + 1;
		        })
		    end
		
		    -- Add hotkey tooltip if alt not held down
		    if not self.state.IsAltDown then
		        Buttons[#Hierarchy + 1] = new(HotkeyTooltip, {
		            IsAltDown = false;
		            DisplayAltHotkey = UserInputService.KeyboardEnabled;
		            LayoutOrder = #Hierarchy + 2;
		        })
		    end
		
		    -- Return list of buttons
		    return Buttons
		end
		
		return ScopeHUD
	end
	fake_module_scripts[script] = module_script
end
do -- nil.HotkeyTooltip
	local script = Instance.new('ModuleScript', nil)
	script.Name = "HotkeyTooltip"
	local function module_script()
		local Root = script.Parent.Parent.Parent
		local Vendor = Root:WaitForChild 'Vendor'
		local Roact = require(Vendor:WaitForChild 'Roact')
		
		-- Components
		local ScopeOutTooltip = require(script:WaitForChild 'ScopeOutTooltip')
		local ScopeLockTooltip = require(script:WaitForChild 'ScopeLockTooltip')
		local ScopeInTooltip = require(script:WaitForChild 'ScopeInTooltip')
		local AltTooltip = require(script:WaitForChild 'AltTooltip')
		
		local function HotkeyTooltip(props)
		    local Tooltip = nil
		
		    -- Select appropriate tooltip
		    if props.IsAltDown then
		        if props.IsScopeParent then
		            Tooltip = Roact.createElement(ScopeOutTooltip, props)
		        elseif props.IsScope and (not props.IsScopeLocked) then
		            Tooltip = Roact.createElement(ScopeLockTooltip, props)
		        elseif props.IsScopable then
		            Tooltip = Roact.createElement(ScopeInTooltip, props)
		        end
		    elseif props.DisplayAltHotkey then
		        Tooltip = Roact.createElement(AltTooltip, props)
		    end
		
		    -- Return tooltip with spacer
		    return Roact.createFragment({
		        Tooltip = Tooltip;
		        Spacer = Tooltip and Roact.createElement('Frame', {
		            BackgroundTransparency = 1;
		            Size = UDim2.new(0, 0, 1, 0);
		            LayoutOrder = props.LayoutOrder and (props.LayoutOrder - 1) or 2;
		        });
		    })
		end
		
		return HotkeyTooltip
	end
	fake_module_scripts[script] = module_script
end
do -- nil.AltTooltip
	local script = Instance.new('ModuleScript', nil)
	script.Name = "AltTooltip"
	local function module_script()
		local Root = script.Parent.Parent.Parent.Parent
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService('TextService')
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Calculate label length
		local LABEL_TEXT = 'ALT'
		local LABEL_LENGTH = TextService:GetTextSize(LABEL_TEXT,
		    21/2, Enum.Font.SourceSansSemibold, Vector2.new(math.huge, math.huge)).X
		
		local function ScopeInTooltip(props)
		    return new('ImageLabel', {
		        BackgroundTransparency = 1;
		        ImageTransparency = 1 - 0.14;
		        Image = 'rbxassetid://4445959523';
		        ScaleType = Enum.ScaleType.Slice;
		        SliceCenter = Rect.new(4, 4, 12, 12);
		        ImageColor3 = Color3.fromRGB(0, 0, 0);
		        Size = UDim2.new(0, LABEL_LENGTH + 8/2, 0, 30/2);
		        LayoutOrder = props.LayoutOrder or 3;
		    },
		    {
		        Label = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Size = UDim2.new(0, LABEL_LENGTH, 1, 0);
		            Position = UDim2.new(0, 5/2, 0.5, 0);
		            AnchorPoint = Vector2.new(0, 0.5);
		            Font = Enum.Font.SourceSansSemibold;
		            TextSize = 21/2;
		            Text = LABEL_TEXT;
		            TextTransparency = 0.5;
		            TextYAlignment = Enum.TextYAlignment.Center;
		            TextColor3 = Color3.fromRGB(255, 255, 255);
		            LayoutOrder = 1;
		        });
		    })
		end
		
		return ScopeInTooltip
	end
	fake_module_scripts[script] = module_script
end
do -- nil.ScopeInTooltip
	local script = Instance.new('ModuleScript', nil)
	script.Name = "ScopeInTooltip"
	local function module_script()
		local Root = script.Parent.Parent.Parent.Parent
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService('TextService')
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Calculate label length
		local LABEL_TEXT = 'Z'
		local LABEL_LENGTH = TextService:GetTextSize(LABEL_TEXT,
		    24/2, Enum.Font.SourceSans, Vector2.new(math.huge, math.huge)).X
		local ICON_SIZE = 21
		
		local function ScopeInTooltip(props)
		    return new('ImageLabel', {
		        BackgroundTransparency = 1;
		        ImageTransparency = 1 - 0.14;
		        Image = 'rbxassetid://4445959523';
		        ScaleType = Enum.ScaleType.Slice;
		        SliceCenter = Rect.new(4, 4, 12, 12);
		        ImageColor3 = Color3.fromRGB(0, 0, 0);
		        Size = UDim2.new(0, LABEL_LENGTH + (ICON_SIZE + 9)/2, 0, 30/2);
		        LayoutOrder = props.LayoutOrder or 3;
		    },
		    {
		        IconWrapper = new('Frame', {
		            Size = UDim2.new(0, ICON_SIZE/2, 0, ICON_SIZE/2);
		            Position = UDim2.new(0, 0, 0.5, 0);
		            AnchorPoint = Vector2.new(0, 0.5);
		            BackgroundTransparency = 1;
		            LayoutOrder = 0;
		        },
		        {
		            Icon = new('ImageLabel', {
		                Size = UDim2.new(1, 0, 1, 0);
		                BackgroundTransparency = 1;
		                ImageTransparency = 0.5;
		                Image = 'rbxassetid://2244452978';
		                ImageRectOffset = Vector2.new(14*3, 0) * 2;
		                ImageRectSize = Vector2.new(14, 14) * 2;
		                Rotation = 90;
		            });
		        });
		        Label = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Size = UDim2.new(0, LABEL_LENGTH, 1, 0);
		            Position = UDim2.new(0, ICON_SIZE/2, 0.5, 0);
		            AnchorPoint = Vector2.new(0, 0.5);
		            Font = Enum.Font.SourceSans;
		            TextSize = 24/2;
		            Text = LABEL_TEXT;
		            TextTransparency = 0.5;
		            TextYAlignment = Enum.TextYAlignment.Center;
		            TextColor3 = Color3.fromRGB(255, 255, 255);
		            LayoutOrder = 1;
		        });
		    })
		end
		
		return ScopeInTooltip
	end
	fake_module_scripts[script] = module_script
end
do -- nil.ScopeLockTooltip
	local script = Instance.new('ModuleScript', nil)
	script.Name = "ScopeLockTooltip"
	local function module_script()
		local Root = script.Parent.Parent.Parent.Parent
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService('TextService')
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Calculate label length
		local LABEL_TEXT = 'F'
		local LABEL_LENGTH = TextService:GetTextSize(LABEL_TEXT,
		    24/2, Enum.Font.SourceSans, Vector2.new(math.huge, math.huge)).X
		local ICON_SIZE = 18
		
		local function ScopeLockTooltip(props)
		    return new('ImageLabel', {
		        BackgroundTransparency = 1;
		        ImageTransparency = 1 - 0.14;
		        Image = 'rbxassetid://4445959523';
		        ScaleType = Enum.ScaleType.Slice;
		        SliceCenter = Rect.new(4, 4, 12, 12);
		        ImageColor3 = Color3.fromRGB(0, 0, 0);
		        Size = UDim2.new(0, LABEL_LENGTH + (ICON_SIZE + 12)/2, 0, 30/2);
		        LayoutOrder = props.LayoutOrder or 3;
		    },
		    {
		        IconWrapper = new('Frame', {
		            Size = UDim2.new(0, ICON_SIZE/2, 0, ICON_SIZE/2);
		            Position = UDim2.new(0, 4/2, 0.5, 0);
		            AnchorPoint = Vector2.new(0, 0.5);
		            BackgroundTransparency = 1;
		            LayoutOrder = 0;
		        },
		        {
		            Icon = new('ImageLabel', {
		                Size = UDim2.new(1, 0, 1, 0);
		                BackgroundTransparency = 1;
		                ImageTransparency = 0.5;
		                Image = 'rbxassetid://2244452978';
		                ImageRectOffset = Vector2.new(14*2, 0) * 2;
		                ImageRectSize = Vector2.new(14, 14) * 2;
		            });
		        });
		        Label = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Size = UDim2.new(0, LABEL_LENGTH, 1, 0);
		            Position = UDim2.new(0, (6 + ICON_SIZE)/2, 0.5, 0);
		            AnchorPoint = Vector2.new(0, 0.5);
		            Font = Enum.Font.SourceSans;
		            TextSize = 24/2;
		            Text = LABEL_TEXT;
		            TextTransparency = 0.5;
		            TextYAlignment = Enum.TextYAlignment.Center;
		            TextColor3 = Color3.fromRGB(255, 255, 255);
		            LayoutOrder = 1;
		        });
		    })
		end
		
		return ScopeLockTooltip
	end
	fake_module_scripts[script] = module_script
end
do -- nil.ScopeOutTooltip
	local script = Instance.new('ModuleScript', nil)
	script.Name = "ScopeOutTooltip"
	local function module_script()
		local Root = script.Parent.Parent.Parent.Parent
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService('TextService')
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Calculate label length
		local LABEL_TEXT = 'SHIFT-Z'
		local LABEL_LENGTH = TextService:GetTextSize(LABEL_TEXT,
		    24/2, Enum.Font.SourceSans, Vector2.new(math.huge, math.huge)).X
		local ICON_SIZE = 21
		
		local function ScopeOutTooltip(props)
		    return new('ImageLabel', {
		        BackgroundTransparency = 1;
		        ImageTransparency = 1 - 0.07;
		        Image = 'rbxassetid://4445959523';
		        ScaleType = Enum.ScaleType.Slice;
		        SliceCenter = Rect.new(4, 4, 12, 12);
		        ImageColor3 = Color3.fromRGB(0, 0, 0);
		        Size = UDim2.new(0, LABEL_LENGTH + (ICON_SIZE + 9)/2, 0, 30/2);
		        LayoutOrder = props.LayoutOrder or 3;
		    },
		    {
		        IconWrapper = new('Frame', {
		            Size = UDim2.new(0, ICON_SIZE/2, 0, ICON_SIZE/2);
		            Position = UDim2.new(0, 0, 0.5, 0);
		            AnchorPoint = Vector2.new(0, 0.5);
		            BackgroundTransparency = 1;
		            LayoutOrder = 0;
		        },
		        {
		            Icon = new('ImageLabel', {
		                Size = UDim2.new(1, 0, 1, 0);
		                BackgroundTransparency = 1;
		                ImageTransparency = 0.7;
		                Image = 'rbxassetid://2244452978';
		                ImageRectOffset = Vector2.new(14*3, 0) * 2;
		                ImageRectSize = Vector2.new(14, 14) * 2;
		                Rotation = -90;
		            });
		        });
		        Label = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Size = UDim2.new(0, LABEL_LENGTH, 1, 0);
		            Position = UDim2.new(0, ICON_SIZE/2, 0.5, 0);
		            AnchorPoint = Vector2.new(0, 0.5);
		            Font = Enum.Font.SourceSans;
		            TextSize = 24/2;
		            Text = LABEL_TEXT;
		            TextTransparency = 0.7;
		            TextYAlignment = Enum.TextYAlignment.Center;
		            TextColor3 = Color3.fromRGB(255, 255, 255);
		            LayoutOrder = 1;
		        });
		    })
		end
		
		return ScopeOutTooltip
	end
	fake_module_scripts[script] = module_script
end
do -- nil.ScopeHierarchyItemButton
	local script = Instance.new('ModuleScript', nil)
	script.Name = "ScopeHierarchyItemButton"
	local function module_script()
		local Root = script.Parent.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService('TextService')
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local Maid = require(Libraries:WaitForChild 'Maid')
		
		-- Roact
		local new = Roact.createElement
		local HotkeyTooltip = require(script.Parent:WaitForChild 'HotkeyTooltip')
		
		-- Create component
		local ScopeHierarchyItemButton = Roact.PureComponent:extend 'ScopeHierarchyItemButton'
		
		--- Creates callbacks and sets up initial state.
		function ScopeHierarchyItemButton:init()
		    self.Maid = Maid.new()
		    self.LayoutRef = Roact.createRef()
		    self.ContainerSize, self.UpdateContainerSize = Roact.createBinding(UDim2.new(0, 0, 1, 0))
		
		    --- Processes clicks, triggers scope change
		    function self.OnClicked()
		        self.props.SetScopeFromButton(self.props.Instance)
		    end
		
		    -- Set initial state
		    self:UpdateInstanceState()
		end
		
		local ClassIconPositions = {
		    Part = Vector2.new(2, 1);
		    MeshPart = Vector2.new(4, 8);
		    UnionOperation = Vector2.new(4, 8);
		    NegateOperation = Vector2.new(3, 8);
		    VehicleSeat = Vector2.new(6, 4);
		    Seat = Vector2.new(6, 4);
		    TrussPart = Vector2.new(2, 1);
		    CornerWedgePart = Vector2.new(2, 1);
		    WedgePart = Vector2.new(2, 1);
		    SpawnLocation = Vector2.new(6, 3);
		    Model = Vector2.new(3, 1);
		    Folder = Vector2.new(8, 8);
		    Tool = Vector2.new(8, 2);
		    Workspace = Vector2.new(10, 2);
		    Accessory = Vector2.new(3, 4);
		    Accoutrement = Vector2.new(3, 4);
		}
		
		--- Updates the current instance state.
		function ScopeHierarchyItemButton:UpdateInstanceState()
		    local NewName = self.props.Instance.Name
		    local MaxTextBounds = Vector2.new(math.huge, math.huge)
		    local TextBounds = TextService:GetTextSize(NewName, 33/2, Enum.Font.SourceSans, MaxTextBounds)
		
		    -- Update instance state
		    self:setState({
		        InstanceName = NewName;
		        InstanceNameLength = TextBounds.X;
		    })
		end
		
		--- Begins listening to the current instance.
		function ScopeHierarchyItemButton:StartTrackingInstance()
		    local NameChanged = self.props.Instance:GetPropertyChangedSignal('Name')
		    self.Maid.NameListener = NameChanged:Connect(function ()
		        self:UpdateInstanceState()
		    end)
		end
		
		--- Update instance state and track changes.
		function ScopeHierarchyItemButton:didMount()
		    self:UpdateInstanceState()
		    self:StartTrackingInstance()
		
		    -- Set up content size listener
		    if self.LayoutRef.current then
		        local Layout = self.LayoutRef.current
		        local LayoutChanged = Layout:GetPropertyChangedSignal('AbsoluteContentSize')
		        self.UpdateContainerSize(UDim2.new(0, Layout.AbsoluteContentSize.X, 0, 38/2))
		        self.Maid.LayoutListener = LayoutChanged:Connect(function ()
		            self.UpdateContainerSize(UDim2.new(0, Layout.AbsoluteContentSize.X, 0, 38/2))
		        end)
		    end
		end
		
		--- Cleans up tracking resources.
		function ScopeHierarchyItemButton:willUnmount()
		    self.Maid:Destroy()
		end
		
		--- Updates state and tracking resources for new instances.
		function ScopeHierarchyItemButton:didUpdate(previousProps, previousState)
		    if previousProps.Instance ~= self.props.Instance then
		        self:UpdateInstanceState()
		        self:StartTrackingInstance()
		    end
		end
		
		function ScopeHierarchyItemButton:render()
		    local ClassName = self.props.Instance.ClassName
		    local IconPosition = ClassIconPositions[ClassName] or Vector2.new(1, 1)
		    local ShouldDisplayArrow = (self.props.LayoutOrder ~= 2) or nil
		
		    return new('ImageButton', {
		        BackgroundTransparency = 1;
		        ImageTransparency = 1;
		        Size = self.ContainerSize;
		        LayoutOrder = self.props.LayoutOrder;
		        [Roact.Event.InputBegan] = self.OnInputBegin;
		        [Roact.Event.InputEnded] = self.OnInputEnd;
		        [Roact.Event.Activated] = self.OnClicked;
		    },
		    {
		        Layout = new('UIListLayout', {
		            [Roact.Ref] = self.LayoutRef;
		            FillDirection = Enum.FillDirection.Horizontal;
		            HorizontalAlignment = Enum.HorizontalAlignment.Left;
		            VerticalAlignment = Enum.VerticalAlignment.Center;
		            SortOrder = Enum.SortOrder.LayoutOrder;
		            Padding = UDim.new(0, 5/2);
		        });
		
		        ArrowWrapper = ShouldDisplayArrow and new('Frame', {
		            Size = UDim2.new(0, 38/2, 0, 38/2);
		            BackgroundTransparency = 1;
		            LayoutOrder = 0;
		        },
		        {
		            Arrow = new('ImageLabel', {
		                Size = UDim2.new(1, 0, 1, 0);
		                BackgroundTransparency = 1;
		                Image = 'rbxassetid://2244452978';
		                ImageRectOffset = Vector2.new(14*3, 0) * 2;
		                ImageRectSize = Vector2.new(14, 14) * 2;
		                ImageTransparency = 0;
		                Rotation = 90;
		            });
		        });
		
		        InstanceInfo = new('Frame', {
		            BackgroundTransparency = 1;
		            Size = UDim2.new(0, self.state.InstanceNameLength + 28/2 + 10/2, 1, 0);
		            LayoutOrder = 1;
		        },
		        {
		            InstanceIcon = new('ImageLabel', {
		                BackgroundTransparency = 1;
		                Image = 'rbxassetid://2245672825';
		                ImageRectOffset = (IconPosition - Vector2.new(1, 1)) * Vector2.new(16, 16);
		                ImageRectSize = Vector2.new(16, 16);
		                ImageTransparency = self.props.IsTarget and 0.5 or 0;
		                AnchorPoint = Vector2.new(0, 0.5);
		                Position = UDim2.new(0, 0, 0.5, 0);
		                Size = UDim2.new(0, 28/2, 0, 28/2);
		                LayoutOrder = 0;
		            });
		            InstanceName = new('TextLabel', {
		                BackgroundTransparency = 1;
		                Size = UDim2.new(0, self.state.InstanceNameLength, 0, 28/2);
		                Position = UDim2.new(0, 28/2 + 10/2, 0.5, 0);
		                AnchorPoint = Vector2.new(0, 0.5);
		                Font = Enum.Font.SourceSans;
		                TextSize = 33/2;
		                Text = self.state.InstanceName;
		                TextTransparency = self.props.IsTarget and 0.5 or 0;
		                TextYAlignment = Enum.TextYAlignment.Center;
		                TextColor3 = Color3.fromRGB(255, 255, 255);
		                LayoutOrder = 1;
		            },
		            {
		                TextShadow = new('TextLabel', {
		                    BackgroundTransparency = 1;
		                    Size = UDim2.new(1, 0, 1, 0);
		                    Position = UDim2.new(0, 0, 0, 1);
		                    Font = Enum.Font.SourceSans;
		                    TextSize = 33/2;
		                    Text = self.state.InstanceName;
		                    TextYAlignment = Enum.TextYAlignment.Center;
		                    TextColor3 = Color3.fromRGB(112, 112, 112);
		                    TextStrokeColor3 = Color3.fromRGB(112, 112, 112);
		                    TextTransparency = self.props.IsTarget and 1 or 0.77;
		                    TextStrokeTransparency = 0.77;
		                    ZIndex = 0;
		                })
		            });
		        });
		
		        Tooltip = new(HotkeyTooltip, {
		            IsScopeParent = self.props.IsScopeParent;
		            IsScope = self.props.IsScope;
		            IsScopable = self.props.IsScopable;
		            IsScopeLocked = self.props.IsScopeLocked;
		            IsAltDown = self.props.IsAltDown;
		        });
		    })
		end
		
		return ScopeHierarchyItemButton
	end
	fake_module_scripts[script] = module_script
end
do -- nil.ModeToggle
	local script = Instance.new('ModuleScript', nil)
	script.Name = "ModeToggle"
	local function module_script()
		local Root = script.Parent.Parent.Parent
		local Vendor = Root:WaitForChild 'Vendor'
		local Libraries = Root:WaitForChild 'Libraries'
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local Maid = require(Libraries:WaitForChild 'Maid')
		
		-- Roact
		local new = Roact.createElement
		local Tooltip = require(script:WaitForChild 'Tooltip')
		
		local ModeToggle = Roact.PureComponent:extend 'ModeToggle'
		
		function ModeToggle:init()
		    self.Maid = Maid.new()
		
		    --- Processes input, listens for hover start
		    function self.OnInputBegin(rbx, Input, WasProcessed)
		        if WasProcessed then
		            return
		        end
		
		        -- Set hovering state
		        if Input.UserInputType.Name == 'MouseMovement' then
		            self:setState({
		                IsHovering = true;
		            })
		        end
		    end
		
		    --- Processes input, listens for hover end
		    function self.OnInputEnd(rbx, Input, WasProcessed)
		        if Input.UserInputType.Name == 'MouseMovement' then
		            self:setState({
		                IsHovering = false;
		            })
		        end
		    end
		
		    --- Processes input, and toggles between targeting modes.
		    function self.OnActivated()
		        self.props.Core.Targeting:ToggleTargetingMode()
		    end
		
		    -- Set initial targeting mode
		    self:setState({
		        TargetingMode = self.props.Core.Targeting.TargetingMode;
		        IsHovering = false;
		    })
		end
		
		function ModeToggle:didMount()
		    local Targeting = self.props.Core.Targeting
		    self.Maid.ModeListener = Targeting.TargetingModeChanged:Connect(function (NewTargetingMode)
		        self:setState({
		            TargetingMode = NewTargetingMode;
		        })
		    end)
		end
		
		function ModeToggle:willUnmount()
		    self.Maid:Destroy()
		end
		
		function ModeToggle:render()
		    local IconSpritesheetPosition = (self.state.TargetingMode == 'Scoped' and 0) or
		                                    (self.state.TargetingMode == 'Direct' and 14)
		    return Roact.createFragment({
		        ModeToggle = new('ImageButton', {
		            BackgroundTransparency = 1;
		            Image = 'rbxassetid://4445959523';
		            ImageTransparency = 1 - (self.state.IsHovering and 0.5 or 0.2);
		            ScaleType = Enum.ScaleType.Slice;
		            SliceCenter = Rect.new(4, 4, 12, 12);
		            ImageColor3 = Color3.fromRGB(131, 131, 131);
		            Size = UDim2.new(0, 36/2, 0, 36/2);
		            LayoutOrder = 0;
		            [Roact.Event.Activated] = self.OnActivated;
		            [Roact.Event.InputBegan] = self.OnInputBegin;
		            [Roact.Event.InputEnded] = self.OnInputEnd;
		        },
		        {
		            Icon = new('ImageLabel', {
		                BackgroundTransparency = 1;
		                Image = 'rbxassetid://4463020853';
		                ImageTransparency = 1 - (self.state.IsHovering and 1 or 0.5);
		                AnchorPoint = Vector2.new(0.5, 0.5);
		                Position = UDim2.new(0.5, 0, 0.5, 0);
		                Size = UDim2.new(0, 28/2, 0, 28/2);
		                ImageRectOffset = Vector2.new(IconSpritesheetPosition, 0);
		                ImageRectSize = Vector2.new(14, 14);
		            });
		            Tooltip = new(Tooltip, {
		                Visible = self.state.IsHovering;
		                IsToolModeEnabled = self.props.IsToolModeEnabled;
		            });
		        });
		        ModeToggleSpacer = new('Frame', {
		            BackgroundTransparency = 1;
		            Size = UDim2.new(0, 0, 1, 0);
		            LayoutOrder = 1;
		        });
		    })
		end
		
		return ModeToggle
	end
	fake_module_scripts[script] = module_script
end
do -- nil.Tooltip
	local script = Instance.new('ModuleScript', nil)
	script.Name = "Tooltip"
	local function module_script()
		local Root = script.Parent.Parent.Parent.Parent
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService('TextService')
		
		-- Libraries
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Text sizes
		local TextBoundaries = Vector2.new(math.huge, math.huge)
		local TITLE_SIZE = TextService:GetTextSize('Selection mode', 24/2, Enum.Font.SourceSans, TextBoundaries)
		local HOTKEY_SIZE = TextService:GetTextSize('SHIFT-T', 24/2, Enum.Font.SourceSans, TextBoundaries)
		local SCOPED_LABEL_SIZE = TextService:GetTextSize('Groups and parts', 25/2, Enum.Font.SourceSans, TextBoundaries)
		local DIRECT_LABEL_SIZE = TextService:GetTextSize('Parts only', 25/2, Enum.Font.SourceSans, TextBoundaries)
		
		local function Tooltip(props)
		    return new('ImageLabel', {
		        AnchorPoint = props.IsToolModeEnabled and
		            Vector2.new(0, 1) or
		            Vector2.new(0, 0);
		        Position = props.IsToolModeEnabled and
		            UDim2.new(0, 0, 0, -12/2) or
		            UDim2.new(0, 0, 1, 12/2);
		        BackgroundTransparency = 1;
		        Image = 'rbxassetid://4445959523';
		        ScaleType = Enum.ScaleType.Slice;
		        SliceCenter = Rect.new(4, 4, 12, 12);
		        ImageColor3 = Color3.fromRGB(67, 67, 67);
		        Size = UDim2.new(0, TITLE_SIZE.X + 15/2 + HOTKEY_SIZE.X + 22/2, 0, 94/2);
		        Visible = props.Visible;
		    },
		    {
		        Arrow = new('Frame', {
		            BackgroundColor3 = Color3.fromRGB(67, 67, 67);
		            BorderSizePixel = 0;
		            AnchorPoint = Vector2.new(0.5, 0.5);
		            Position = props.IsToolModeEnabled and
		                UDim2.new(0, 18/2, 1, 0) or
		                UDim2.new(0, 18/2, 0, 0);
		            Size = UDim2.new(0, 10/2, 0, 10/2);
		            Rotation = 45;
		        });
		        Title = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Font = Enum.Font.SourceSans;
		            TextSize = 24/2;
		            TextColor3 = Color3.new(1, 1, 1);
		            TextTransparency = 1 - 0.6;
		            Text = 'Selection mode';
		            Size = UDim2.new(0, TITLE_SIZE.X, 0, TITLE_SIZE.Y);
		            Position = UDim2.new(0, 8/2, 0, 5/2 + 2);
		        });
		        Hotkey = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Font = Enum.Font.SourceSansSemibold;
		            TextSize = 20/2;
		            TextColor3 = Color3.new(1, 1, 1);
		            TextTransparency = 0;
		            Text = 'SHIFT-T';
		            Size = UDim2.new(0, HOTKEY_SIZE.X, 0, HOTKEY_SIZE.Y);
		            Position = UDim2.new(0, 8/2 + TITLE_SIZE.X + 15/2, 0, 5/2 + 2);
		        });
		        ScopedIcon = new('ImageLabel', {
		            BackgroundTransparency = 1;
		            Image = 'rbxassetid://4463020853';
		            ImageTransparency = 1 - 0.4;
		            Position = UDim2.fromOffset(
		                8/2,
		                5/2 + TITLE_SIZE.Y + 2
		            );
		            Size = UDim2.new(0, 28/2, 0, 28/2);
		            ImageRectOffset = Vector2.new(0, 0);
		            ImageRectSize = Vector2.new(14, 14);
		        });
		        ScopedLabel = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Font = Enum.Font.SourceSans;
		            TextSize = 25/2;
		            TextColor3 = Color3.new(1, 1, 1);
		            Text = 'Groups and parts';
		            Size = UDim2.new(0, SCOPED_LABEL_SIZE.X, 0, SCOPED_LABEL_SIZE.Y);
		            Position = UDim2.fromOffset(
		                (8 + 26 + 8)/2,
		                5/2 + TITLE_SIZE.Y + 2
		            );
		            TextXAlignment = Enum.TextXAlignment.Left;
		        });
		        DirectIcon = new('ImageLabel', {
		            BackgroundTransparency = 1;
		            Image = 'rbxassetid://4463020853';
		            ImageTransparency = 1 - 0.4;
		            Position = UDim2.fromOffset(
		                8/2,
		                5/2 + TITLE_SIZE.Y + 2 + SCOPED_LABEL_SIZE.Y + 1
		            );
		            Size = UDim2.new(0, 28/2, 0, 28/2);
		            ImageRectOffset = Vector2.new(14, 0);
		            ImageRectSize = Vector2.new(14, 14);
		        });
		        DirectLabel = new('TextLabel', {
		            BackgroundTransparency = 1;
		            Font = Enum.Font.SourceSans;
		            TextSize = 25/2;
		            TextColor3 = Color3.new(1, 1, 1);
		            Text = 'Parts only';
		            Size = UDim2.new(0, DIRECT_LABEL_SIZE.X, 0, DIRECT_LABEL_SIZE.Y);
		            Position = UDim2.fromOffset(
		                (8 + 26 + 8)/2,
		                5/2 + TITLE_SIZE.Y + 2 + SCOPED_LABEL_SIZE.Y + 1
		            );
		            TextXAlignment = Enum.TextXAlignment.Left;
		        });
		    })
		end
		
		return Tooltip
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.ScrollingFrame
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "ScrollingFrame"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		
		-- Roact
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Create component
		local ScrollingFrame = Roact.PureComponent:extend 'ScrollingFrame'
		
		-- Set defaults
		ScrollingFrame.defaultProps = {
		    BackgroundTransparency = 1,
		    BorderSizePixel = 0,
		    Size = UDim2.new(1, 0, 1, 0),
		    CanvasSize = UDim2.new(1, 0, 1, 0)
		}
		
		function ScrollingFrame:render()
		    local props = Support.CloneTable(self.props)
		    local state = self.state
		
		    -- Include aspect ratio constraint if specified
		    if props.AspectRatio then
		        local Constraint = new('UIAspectRatioConstraint', {
		            AspectRatio = props.AspectRatio
		        })
		
		        -- Insert constraint into children
		        props[Roact.Children] = Support.Merge(
		            { AspectRatio = Constraint },
		            props[Roact.Children] or {}
		        )
		    end
		
		    -- Include list layout if specified
		    if props.Layout == 'List' then
		        local Layout = new('UIListLayout', {
		            FillDirection = props.LayoutDirection,
		            Padding = props.LayoutPadding,
		            HorizontalAlignment = props.HorizontalAlignment,
		            VerticalAlignment = props.VerticalAlignment,
		            SortOrder = props.SortOrder or 'LayoutOrder',
		            [Roact.Ref] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end,
		            [Roact.Change.AbsoluteContentSize] = function (rbx)
		                self:UpdateContentSize(rbx)
		            end
		        })
		
		        -- Update size
		        props.Size = self:GetSize()
		        props.CanvasSize = self:GetCanvasSize()
		
		        -- Insert layout into children
		        props[Roact.Children] = Support.Merge(
		            { Layout = Layout },
		            props[Roact.Children] or {}
		        )
		    end
		
		    -- Filter out custom properties
		    props.AspectRatio = nil
		    props.Layout = nil
		    props.LayoutDirection = nil
		    props.LayoutPadding = nil
		    props.HorizontalAlignment = nil
		    props.VerticalAlignment = nil
		    props.SortOrder = nil
		    props.Width = nil
		    props.Height = nil
		    props.CanvasWidth = nil
		    props.CanvasHeight = nil
		
		    -- Display component in wrapper
		    return new('ScrollingFrame', props)
		
		end
		
		function ScrollingFrame:GetSize(ContentSize)
		    local props = self.props
		
		    -- Determine dynamic dimensions
		    local DynamicWidth = props.Size == 'WRAP_CONTENT' or
		        props.Width == 'WRAP_CONTENT'
		    local DynamicHeight = props.Size == 'WRAP_CONTENT' or
		        props.Height == 'WRAP_CONTENT'
		    local DynamicSize = DynamicWidth or DynamicHeight
		    
		    -- Calculate size based on content if dynamic
		    return UDim2.new(
		        (ContentSize and DynamicWidth) and UDim.new(0, ContentSize.X) or
		            (typeof(props.Width) == 'UDim' and props.Width or props.Size.X),
		        (ContentSize and DynamicHeight) and UDim.new(0, ContentSize.Y) or
		            (typeof(props.Height) == 'UDim' and props.Height or props.Size.Y)
		    )
		end
		
		function ScrollingFrame:GetCanvasSize(ContentSize)
		    local props = self.props
		
		    -- Determine dynamic canvas dimensions
		    local DynamicCanvasWidth = props.CanvasSize == 'WRAP_CONTENT' or
		        props.CanvasWidth == 'WRAP_CONTENT'
		    local DynamicCanvasHeight = props.CanvasSize == 'WRAP_CONTENT' or
		        props.CanvasHeight == 'WRAP_CONTENT'
		    local DynamicCanvasSize = DynamicCanvasWidth or DynamicCanvasHeight
		
		    -- Calculate size based on content if dynamic
		    return UDim2.new(
		        (ContentSize and DynamicCanvasWidth) and UDim.new(0, ContentSize.X) or
		            (typeof(props.CanvasWidth) == 'UDim' and props.CanvasWidth or props.CanvasSize.X),
		        (ContentSize and DynamicCanvasHeight) and UDim.new(0, ContentSize.Y) or
		            (typeof(props.CanvasHeight) == 'UDim' and props.CanvasHeight or props.CanvasSize.Y)
		    )
		end
		
		function ScrollingFrame:UpdateContentSize(Layout)
		    if not (Layout and Layout.Parent) then
		        return
		    end
		
		    -- Set container size based on content
		    Layout.Parent.Size = self:GetSize(Layout.AbsoluteContentSize)
		    Layout.Parent.CanvasSize = self:GetCanvasSize(Layout.AbsoluteContentSize)
		end
		
		return ScrollingFrame
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.TextBox
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "TextBox"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService 'TextService'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		
		-- Roact
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Create component
		local TextBox = Roact.PureComponent:extend 'TextBox'
		
		-- Set defaults
		TextBox.defaultProps = {
		    BackgroundTransparency = 1,
		    BorderSizePixel = 0,
		    Size = UDim2.new(1, 0, 1, 0),
		    TextSize = 16,
		    Font = 'SourceSans',
		    TextColor3 = Color3.new(0, 0, 0),
		    TextXAlignment = 'Left'
		}
		
		-- Constants
		local INFINITE_BOUNDS = Vector2.new(math.huge, math.huge)
		
		function TextBox:getSize()
		
		    -- Return size directly if fixed
		    if not (self.props.Width or self.props.Height or self.props.Size == 'WRAP_CONTENT') then
		        return self.props.Size
		    end
		
		    -- Get fixed sizes for individual axes
		    local Width, Height
		    if typeof(self.props.Width) == 'UDim' then
		        Width = self.props.Width
		    elseif typeof(self.props.Height) == 'UDim' then
		        Height = self.props.Height
		    end
		
		    -- Get text size from height if autoscaled
		    local TextSize = self.props.TextSize
		    if self.props.TextScaled and self.AbsoluteSize then
		        TextSize = self.AbsoluteSize.Y
		    end
		
		    -- Calculate content bounds
		    local Bounds = TextService:GetTextSize(
		        self.props.Text,
		        TextSize,
		        self.props.Font,
		        INFINITE_BOUNDS
		    )
		
		    -- Set width and height based on content if requested
		    if not Width and (self.props.Width == 'WRAP_CONTENT' or self.props.Size == 'WRAP_CONTENT') then
		        Width = UDim.new(0, Bounds.X)
		    end
		    if not Height and (self.props.Height == 'WRAP_CONTENT' or self.props.Size == 'WRAP_CONTENT') then
		        Height = UDim.new(0, Bounds.Y)
		    end
		
		    -- Return the calculated size
		    return UDim2.new(
		        Width or (self.props.Size and self.props.Size.X) or UDim.new(),
		        Height or (self.props.Size and self.props.Size.Y) or UDim.new()
		    )
		
		end
		
		function TextBox:updateSize()
		
		    -- Calculate new size
		    local Size = self:getSize()
		    local TextSize = self.props.TextScaled and
		        (self.AbsoluteSize and self.AbsoluteSize.Y) or
		        self.props.TextSize
		
		    -- Check if state is outdated
		    if self.state.Size ~= Size or
		        self.state.TextSize ~= TextSize then
		
		        -- Update state
		        self:setState {
		            Size = Size,
		            TextSize = TextSize
		        }
		    end
		end
		
		function TextBox:init()
		    self.Updating = true
		    self.state = {
		        Size = UDim2.new(),
		        TextSize = 0
		    }
		end
		
		function TextBox:willUpdate(nextProps, nextState)
		    self.Updating = true
		end
		
		function TextBox:render()
		    local props = Support.Merge({}, self.props, {
		
		        -- Override size
		        Size = self.state.Size,
		        TextSize = self.state.TextSize,
		        TextScaled = false,
		
		        -- Get initial size
		        [Roact.Ref] = function (rbx)
		            self.AbsoluteSize = rbx and
		                rbx.AbsoluteSize or
		                self.AbsoluteSize
		        end,
		
		        -- Track size changes
		        [Roact.Change.AbsoluteSize] = function (rbx)
		            self.AbsoluteSize = rbx.AbsoluteSize
		            if not self.Updating then
		                self:updateSize()
		            end
		        end
		
		    })
		
		    -- Parse hex colors
		    if type(props.TextColor) == 'string' then
		        local R, G, B = props.TextColor:lower():match('#?(..)(..)(..)')
		        props.TextColor3 = Color3.fromRGB(tonumber(R, 16), tonumber(G, 16), tonumber(B, 16))
		    end
		
		    -- Separate children from props
		    local children = Support.Merge({}, self.props[Roact.Children])
		
		    -- Clear invalid props
		    props.Width = nil
		    props.Height = nil
		    props.Bold = nil
		    props.TextColor = nil
		    props[Roact.Children] = nil
		
		    -- Add a bold layer if specified
		    if self.props.Bold then
		        local BoldProps = Support.CloneTable(props)
		        BoldProps.Size = UDim2.new(1, 0, 1, 0)
		        BoldProps.Position = nil
		        BoldProps.TextScaled = true
		        BoldProps.AnchorPoint = nil
		        children.Bold = new(TextBox, BoldProps)
		    end
		
		    -- Display component in wrapper
		    return new('TextBox', props, children)
		
		end
		
		function TextBox:didMount()
		    self.Updating = nil
		    self:updateSize()
		end
		
		function TextBox:didUpdate(previousProps, previousState)
		    self.Updating = nil
		    self:updateSize()
		end
		
		return TextBox
	end
	fake_module_scripts[script] = module_script
end
do -- f3xUi.TextLabel
	local script = Instance.new('ModuleScript', f3xUi)
	script.Name = "TextLabel"
	local function module_script()
		local Root = script.Parent.Parent
		local Libraries = Root:WaitForChild 'Libraries'
		local Vendor = Root:WaitForChild 'Vendor'
		local TextService = game:GetService 'TextService'
		
		-- Libraries
		local Support = require(Libraries:WaitForChild 'SupportLibrary')
		
		-- Roact
		local Roact = require(Vendor:WaitForChild 'Roact')
		local new = Roact.createElement
		
		-- Create component
		local TextLabel = Roact.PureComponent:extend 'TextLabel'
		
		-- Set defaults
		TextLabel.defaultProps = {
		    BackgroundTransparency = 1,
		    BorderSizePixel = 0,
		    Size = UDim2.new(1, 0, 1, 0),
		    TextSize = 16,
		    Font = 'SourceSans',
		    TextColor3 = Color3.new(0, 0, 0),
		    TextXAlignment = 'Left'
		}
		
		-- Constants
		local INFINITE_BOUNDS = Vector2.new(math.huge, math.huge)
		
		function TextLabel:getSize()
		
		    -- Return size directly if fixed
		    if not (self.props.Width or self.props.Height or self.props.Size == 'WRAP_CONTENT') then
		        return self.props.Size
		    end
		
		    -- Get fixed sizes for individual axes
		    local Width, Height
		    if typeof(self.props.Width) == 'UDim' then
		        Width = self.props.Width
		    elseif typeof(self.props.Height) == 'UDim' then
		        Height = self.props.Height
		    end
		
		    -- Get text size from height if autoscaled
		    local TextSize = self.props.TextSize
		    if self.props.TextScaled and self.AbsoluteSize then
		        TextSize = self.AbsoluteSize.Y
		    end
		
		    -- Calculate content bounds
		    local Bounds = TextService:GetTextSize(
		        self.props.Text,
		        TextSize,
		        self.props.Font,
		        INFINITE_BOUNDS
		    )
		
		    -- Set width and height based on content if requested
		    if not Width and (self.props.Width == 'WRAP_CONTENT' or self.props.Size == 'WRAP_CONTENT') then
		        Width = UDim.new(0, Bounds.X)
		    end
		    if not Height and (self.props.Height == 'WRAP_CONTENT' or self.props.Size == 'WRAP_CONTENT') then
		        Height = UDim.new(0, Bounds.Y)
		    end
		
		    -- Return the calculated size
		    return UDim2.new(
		        Width or (self.props.Size and self.props.Size.X) or UDim.new(),
		        Height or (self.props.Size and self.props.Size.Y) or UDim.new()
		    )
		
		end
		
		function TextLabel:updateSize()
		    if not self.Mounted then
		        return
		    end
		
		    -- Calculate new size
		    local Size = self:getSize()
		    local TextSize = self.props.TextScaled and
		        (self.AbsoluteSize and self.AbsoluteSize.Y) or
		        self.props.TextSize
		
		    -- Check if state is outdated
		    if self.state.Size ~= Size or
		        self.state.TextSize ~= TextSize then
		
		        -- Update state
		        self:setState {
		            Size = Size,
		            TextSize = TextSize
		        }
		    end
		end
		
		function TextLabel:init()
		    self.Updating = true
		    self.state = {
		        Size = UDim2.new(),
		        TextSize = 0
		    }
		end
		
		function TextLabel:willUpdate(nextProps, nextState)
		    self.Updating = true
		end
		
		function TextLabel:render()
		    local props = Support.Merge({}, self.props, {
		
		        -- Override size
		        Size = self.state.Size,
		        TextSize = self.state.TextSize,
		        TextScaled = false,
		
		        -- Get initial size
		        [Roact.Ref] = function (rbx)
		            self.AbsoluteSize = rbx and
		                rbx.AbsoluteSize or
		                self.AbsoluteSize
		        end,
		
		        -- Track size changes
		        [Roact.Change.AbsoluteSize] = function (rbx)
		            self.AbsoluteSize = rbx.AbsoluteSize
		            if not self.Updating then
		                self:updateSize()
		            end
		        end
		
		    })
		
		    -- Parse hex colors
		    if type(props.TextColor) == 'string' then
		        local R, G, B = props.TextColor:lower():match('#?(..)(..)(..)')
		        props.TextColor3 = Color3.fromRGB(tonumber(R, 16), tonumber(G, 16), tonumber(B, 16))
		    end
		
		    -- Separate children from props
		    local children = Support.Merge({}, self.props[Roact.Children])
		
		    -- Clear invalid props
		    props.Width = nil
		    props.Height = nil
		    props.Bold = nil
		    props.TextColor = nil
		    props.AspectRatio = nil
		    props[Roact.Children] = nil
		
		    -- Include aspect ratio constraint if specified
		    if self.props.AspectRatio then
		        local Constraint = new('UIAspectRatioConstraint', {
		            AspectRatio = self.props.AspectRatio
		        })
		
		        -- Insert constraint into children
		        children.AspectRatio = Constraint
		    end
		
		    -- Add a bold layer if specified
		    if self.props.Bold then
		        local BoldProps = Support.CloneTable(props)
		        BoldProps.Size = UDim2.new(1, 0, 1, 0)
		        BoldProps.Position = nil
		        BoldProps.TextScaled = true
		        BoldProps.AnchorPoint = nil
		        children.Bold = new(TextLabel, BoldProps)
		    end
		
		    -- Display component in wrapper
		    return new('TextLabel', props, children)
		
		end
		
		function TextLabel:didMount()
		    self.Updating = nil
		    self.Mounted = true
		    self:updateSize()
		end
		
		function TextLabel:willUnmount()
		    self.Mounted = nil
		end
		
		function TextLabel:didUpdate(previousProps, previousState)
		    self.Updating = nil
		    self:updateSize()
		end
		
		return TextLabel
	end
	fake_module_scripts[script] = module_script
end
